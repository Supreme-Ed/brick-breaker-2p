<!DOCTYPE html>
<html>
<head>
    <title>Two-Player Brick Breaker</title>
    <style>
        canvas {
            border: 1px solid black;
            background-color: #000;
        }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
        }
        #startScreen {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px;
            text-align: center;
            border-radius: 10px;
            font-family: Arial, sans-serif;
        }
        .button {
            background: #4CAF50;
            color: white;
            padding: 10px 20px;
            margin: 10px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        .button:hover {
            background: #45a049;
        }
        .controls {
            margin: 20px;
            text-align: left;
            font-size: 14px;
        }
        /* Power-up indicator styles */
        .power-up-indicator {
            position: absolute;
            padding: 5px 10px;
            border-radius: 5px;
            font-family: Arial, sans-serif;
            font-size: 14px;
            color: white;
            background-color: rgba(0, 0, 0, 0.6);
        }
        #player1PowerUp {
            bottom: 10px;
            left: 10px;
        }
        #player2PowerUp {
            top: 10px;
            right: 10px;
        }
    </style>
</head>
<body>
    <div id="startScreen">
        <h1>Brick Breaker</h1>
        <div class="controls">
            <h2>Controls:</h2>
            <p><strong>Player 1 (Bottom):</strong> Left/Right Arrow Keys, Space to shoot freeze ray/laser</p>
            <p><strong>Player 2 (Top):</strong> A/D Keys, S to shoot freeze ray/laser</p>
            <p>Press <strong>ESC</strong> key to exit the game to main menu</p>
            <p>Break all bricks to win extra points!</p>
            <p>Hit blue bricks to get the freeze ray power-up!</p>
            <p>Hit purple bricks to get the wide paddle power-up!</p>
            <p>Hit red bricks to get the laser power-up that turns opponents to ashes!</p>
        </div>
        <button class="button" onclick="startGame(1)">Single Player</button>
        <button class="button" onclick="startGame(2)">Two Players</button>
        <button class="button" onclick="startGame(3)">AI vs. AI</button>
    </div>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="player1PowerUp" class="power-up-indicator" style="display: none;">Freeze Ray Ready!</div>
    <div id="player2PowerUp" class="power-up-indicator" style="display: none;">Freeze Ray Ready!</div>
    <div id="player1LaserPowerUp" class="power-up-indicator" style="display: none; background-color: rgba(255, 50, 0, 0.7); bottom: 40px;">Laser Ready!</div>
    <div id="player2LaserPowerUp" class="power-up-indicator" style="display: none; background-color: rgba(255, 50, 0, 0.7); top: 40px;">Laser Ready!</div>

    <script>
        // Debug helper - logs to console for easier debugging
        function debug(message) {
            console.log(`[DEBUG] ${message}`);
        }

        // Game setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startScreen = document.getElementById('startScreen');
        const player1PowerUpIndicator = document.getElementById('player1PowerUp');
        const player2PowerUpIndicator = document.getElementById('player2PowerUp');
        const player1LaserIndicator = document.getElementById('player1LaserPowerUp');
        const player2LaserIndicator = document.getElementById('player2LaserPowerUp');
        let gameMode = 0; // 0 = not started, 1 = single player, 2 = two players, 3 = AI vs AI
        let gameLoop;

        // Game objects
        const paddle1 = {
            x: 350,
            y: canvas.height - 30,
            width: 100,
            height: 10,
            dx: 0,
            score: 0,
            curvature: 0.3, // Curvature factor for concave shape
            hasFreezeRay: false,
            isFrozen: false,
            frozenTimeRemaining: 0,
            isWide: false, // New property for wide paddle power-up
            widePaddleTimeRemaining: 0, // Timer for wide paddle duration
            originalWidth: 100, // Store original width to restore later
            hasLaser: false, // New property for laser power-up
            isAshes: false, // New property to track if turned to ashes
            ashesTimeRemaining: 0, // Timer for ashes duration
        };

        const paddle2 = {
            x: 350,
            y: 30,
            width: 100,
            height: 10,
            dx: 0,
            score: 0,
            curvature: 0.3, // Curvature factor for concave shape
            hasFreezeRay: false,
            isFrozen: false,
            frozenTimeRemaining: 0,
            isWide: false, // New property for wide paddle power-up
            widePaddleTimeRemaining: 0, // Timer for wide paddle duration
            originalWidth: 100, // Store original width to restore later
            hasLaser: false, // New property for laser power-up
            isAshes: false, // New property to track if turned to ashes
            ashesTimeRemaining: 0, // Timer for ashes duration
        };

        // Freeze ray objects
        const freezeRays = [];

        // Array to hold laser beams
        const laserBeams = [];

        // Class for freeze ray
        class FreezeRay {
            constructor(x, y, player) {
                this.x = x;
                this.y = y;
                this.width = 5;
                this.height = player === 1 ? -canvas.height : canvas.height; // Negative for upward ray
                this.player = player; // Player who shot the ray
                this.speed = 12; // Speed of the ray
                this.active = true; // Whether ray is still active
                this.alphaValue = 1.0; // For fade-out animation
                this.hitTarget = false; // If ray hit the target
                this.progress = 0; // 0 to 1, how far the ray has traveled
            }
            
            update() {
                // Once ray hits, start fading
                if (this.hitTarget) {
                    this.alphaValue -= 0.05; // Fade out
                    if (this.alphaValue <= 0) {
                        this.active = false; // Remove ray when fully faded
                    }
                    return;
                }
                
                // Calculate ray progress (0 to 1)
                this.progress += this.speed / Math.abs(this.height);
                
                // Check if ray hit opponent paddle
                if (this.progress >= 1) {
                    const targetPaddle = this.player === 1 ? paddle2 : paddle1;
                    const hitX = this.x;
                    
                    // Check if ray hit the paddle horizontally
                    if (hitX >= targetPaddle.x && hitX <= targetPaddle.x + targetPaddle.width) {
                        // Hit! Freeze the paddle
                        targetPaddle.isFrozen = true;
                        targetPaddle.frozenTimeRemaining = 10; // 10 seconds freeze
                        debug(`Player ${this.player === 1 ? 2 : 1} frozen for 10 seconds!`);
                        
                        this.hitTarget = true;
                        soundFX.playFreezeRay(); // Instead of soundManager.play('freezeRay')
                    } else {
                        debug(`Freeze ray missed!`);
                        this.hitTarget = true;
                        soundFX.playMiss(); // Instead of soundManager.play('miss')
                    }
                }
            }
            
            destroyBrick(c, r) {
                // Check if we've already processed this brick
                const brickKey = `${c},${r}`;
                if (this.affectedBricks.includes(brickKey)) {
                    return;
                }
                
                // Mark this brick as affected
                this.affectedBricks.push(brickKey);
                
                // Add points to the player who shot the laser
                if (this.player === 1) {
                    paddle1.score += 5;
                    debug(`Player 1 scored 5 points for lasering a brick`);
                } else {
                    paddle2.score += 5;
                    debug(`${gameMode === 1 ? 'AI' : 'Player 2'} scored 5 points for lasering a brick`);
                }
                
                // Create ash particles (more than regular brick breaking)
                createAshParticles(bricks[c][r], 30);
                
                // Destroy the brick
                bricks[c][r].status = 0;
                soundFX.playBrickBreak();
                debug(`Brick at [${c},${r}] turned to ashes by laser`);
            }
            
            draw() {
                ctx.save();
                
                if (this.hitTarget) {
                    // Draw fade out effect when hit
                    ctx.globalAlpha = this.alphaValue;
                    ctx.beginPath();
                    ctx.strokeStyle = "#00FFFF";
                    ctx.lineWidth = this.width * 0.4;
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.x, this.y + this.height * this.progress);
                    ctx.stroke();
                    ctx.closePath();
                } else {
                    // Draw active laser beam
                    this.drawLaserBeam(this.progress);
                }
                
                ctx.restore();
            }
            
            drawLaserBeam(progress) {
                // Draw core beam (yellow)
                ctx.beginPath();
                ctx.strokeStyle = "#FFDD00";
                ctx.lineWidth = this.width * 0.4;
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x, this.y + this.height * progress);
                ctx.stroke();
                ctx.closePath();
                
                // Draw outer beam (red)
                ctx.beginPath();
                ctx.strokeStyle = "#FF4400";
                ctx.lineWidth = this.width;
                ctx.globalAlpha = 0.7;
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x, this.y + this.height * progress);
                ctx.stroke();
                ctx.closePath();
                
                // Draw impact point
                const impactY = this.y + this.height * progress;
                ctx.beginPath();
                ctx.fillStyle = "#FFFFFF";
                ctx.arc(this.x, impactY, this.width/2 + 5, 0, Math.PI * 2);
                ctx.globalAlpha = 0.8;
                ctx.fill();
                ctx.closePath();
                
                // Draw flame effects
                const numFlames = 5;
                for (let i = 0; i < numFlames; i++) {
                    const flameHeight = this.width * (0.5 + Math.random() * 0.5);
                    const flameWidth = this.width * (0.2 + Math.random() * 0.3);
                    const flameX = this.x + (Math.random() - 0.5) * this.width * 0.8;
                    const flameY = impactY + (this.player === 1 ? -flameHeight : 0);
                    
                    // Create gradient for flame
                    const gradient = ctx.createLinearGradient(flameX, flameY, flameX, flameY + (this.player === 1 ? -flameHeight : flameHeight));
                    gradient.addColorStop(0, "#FFFFFF");
                    gradient.addColorStop(0.3, "#FFDD00");
                    gradient.addColorStop(1, "#FF4400");
                    
                    ctx.beginPath();
                    ctx.fillStyle = gradient;
                    ctx.globalAlpha = 0.7 * this.alphaValue;
                    
                    // Draw flame shape
                    if (this.player === 1) {
                        // Upward flame
                        ctx.moveTo(flameX - flameWidth/2, flameY);
                        ctx.quadraticCurveTo(flameX - flameWidth/4, flameY - flameHeight/2, flameX, flameY - flameHeight);
                        ctx.quadraticCurveTo(flameX + flameWidth/4, flameY - flameHeight/2, flameX + flameWidth/2, flameY);
                    } else {
                        // Downward flame
                        ctx.moveTo(flameX - flameWidth/2, flameY);
                        ctx.quadraticCurveTo(flameX - flameWidth/4, flameY + flameHeight/2, flameX, flameY + flameHeight);
                        ctx.quadraticCurveTo(flameX + flameWidth/4, flameY + flameHeight/2, flameX + flameWidth/2, flameY);
                    }
                    
                    ctx.closePath();
                    ctx.fill();
                }
            }
        }

        // Update ball to be an array of two balls
        const balls = [
            {
                x: canvas.width / 2,
                y: canvas.height - 50, // Bottom player's ball
                radius: 8,
                dx: 2,
                dy: -2,
                owner: 1, // Player 1's ball
                lastHitBy: 1 // Track which player last hit the ball
            },
            {
                x: canvas.width / 2,
                y: 50, // Top player's ball
                radius: 8,
                dx: -2,
                dy: 2,
                owner: 2, // Player 2's ball
                lastHitBy: 2 // Track which player last hit the ball
            }
        ];

        // Brick configuration
        const brickRowCount = 3;
        const brickColumnCount = 8;
        const brickWidth = 75;
        const brickHeight = 20;
        const brickPadding = 10;
        const brickOffsetTop = canvas.height / 2 - (brickRowCount * (brickHeight + brickPadding)) / 2;
        const brickOffsetLeft = (canvas.width - (brickColumnCount * (brickWidth + brickPadding))) / 2;

        // Create bricks array
        const bricks = [];
        let currentPattern = 0; // Track the current pattern
        const BRICK_NORMAL = 1;
        const BRICK_POWER_UP = 2;
        const BRICK_WIDE_PADDLE = 3; // New constant for wide paddle power-up
        const BRICK_LASER_POWER_UP = 4; // New constant for laser power-up

        // Initialize bricks with different patterns
        function initBricks() {
            debug("Initializing bricks");
            
            // Clear existing bricks
            for (let c = 0; c < brickColumnCount; c++) {
                bricks[c] = [];
                for (let r = 0; r < brickRowCount; r++) {
                    bricks[c][r] = { status: 0 };
                }
            }
            
            // Choose a new pattern, different from the current one
            let newPattern;
            do {
                newPattern = Math.floor(Math.random() * 5); // 5 different patterns
            } while (newPattern === currentPattern && 5 > 1);
            
            currentPattern = newPattern;
            debug(`Selected brick pattern: ${currentPattern}`);
            
            // Apply the selected pattern
            switch (currentPattern) {
                case 0:
                    // Standard grid pattern
                    createStandardPattern();
                    break;
                case 1:
                    // Checkerboard pattern
                    createCheckerboardPattern();
                    break;
                case 2:
                    // Diamond pattern
                    createDiamondPattern();
                    break;
                case 3:
                    // Random pattern
                    createRandomPattern();
                    break;
                case 4:
                    // Zigzag pattern
                    createZigzagPattern();
                    break;
            }
            
            // Add power-up bricks (blue bricks)
            addPowerUpBricks();
            
            debug(`Created pattern with ${countActiveBricks()} active bricks`);
        }
        
        // Add some power-up bricks to the layout
        function addPowerUpBricks() {
            // Add 2-3 power-up bricks
            const numPowerUps = 2 + Math.floor(Math.random() * 2);
            let powerUpsAdded = 0;
            
            while (powerUpsAdded < numPowerUps) {
                const c = Math.floor(Math.random() * brickColumnCount);
                const r = Math.floor(Math.random() * brickRowCount);
                
                // Only convert active normal bricks to power-up bricks
                if (bricks[c][r].status === BRICK_NORMAL) {
                    bricks[c][r].status = BRICK_POWER_UP;
                    bricks[c][r].color = "#0088FF"; // Blue color for power-up bricks
                    powerUpsAdded++;
                    debug(`Added power-up brick at [${c},${r}]`);
                }
            }
            
            // Add 2-3 wide paddle power-up bricks (purple)
            const numWidePaddlePowerUps = 2 + Math.floor(Math.random() * 2);
            let widePaddlePowerUpsAdded = 0;
            
            while (widePaddlePowerUpsAdded < numWidePaddlePowerUps) {
                const c = Math.floor(Math.random() * brickColumnCount);
                const r = Math.floor(Math.random() * brickRowCount);
                
                // Only convert active normal bricks to wide paddle power-up bricks
                if (bricks[c][r].status === BRICK_NORMAL) {
                    bricks[c][r].status = BRICK_WIDE_PADDLE;
                    bricks[c][r].color = "#8800CC"; // Purple color for wide paddle power-up bricks
                    widePaddlePowerUpsAdded++;
                    debug(`Added wide paddle power-up brick at [${c},${r}]`);
                }
            }
            
            // Add 2-3 laser power-up bricks (red)
            const numLaserPowerUps = 2 + Math.floor(Math.random() * 2);
            let laserPowerUpsAdded = 0;
            
            while (laserPowerUpsAdded < numLaserPowerUps) {
                const c = Math.floor(Math.random() * brickColumnCount);
                const r = Math.floor(Math.random() * brickRowCount);
                
                // Only convert active normal bricks to laser power-up bricks
                if (bricks[c][r].status === BRICK_NORMAL) {
                    bricks[c][r].status = BRICK_LASER_POWER_UP;
                    bricks[c][r].color = "#FF3300"; // Red color for laser power-up bricks
                    laserPowerUpsAdded++;
                    debug(`Added laser power-up brick at [${c},${r}]`);
                }
            }
        }

        // Helper to count active bricks
        function countActiveBricks() {
            let count = 0;
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    if (bricks[c][r].status > 0) count++;
                }
            }
            return count;
        }

        // Standard grid pattern
        function createStandardPattern() {
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    const hue = (c * r * 360) / (brickColumnCount * brickRowCount);
                    const saturation = 70 + Math.random() * 20;
                    const lightness = 50 + Math.random() * 10;
                    bricks[c][r] = { 
                        x: 0, 
                        y: 0, 
                        status: BRICK_NORMAL,
                        color: `hsl(${hue}, ${saturation}%, ${lightness}%)`
                    };
                }
            }
        }

        // Checkerboard pattern
        function createCheckerboardPattern() {
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    const isActive = (c + r) % 2 === 0;
                    const hue = (c * r * 360) / (brickColumnCount * brickRowCount);
                    const saturation = 70 + Math.random() * 20;
                    const lightness = 50 + Math.random() * 10;
                    bricks[c][r] = { 
                        x: 0, 
                        y: 0, 
                        status: isActive ? BRICK_NORMAL : 0,
                        color: `hsl(${hue}, ${saturation}%, ${lightness}%)`
                    };
                }
            }
        }

        // Diamond pattern
        function createDiamondPattern() {
            const centerC = Math.floor(brickColumnCount / 2);
            const centerR = Math.floor(brickRowCount / 2);
            const maxDistance = Math.max(centerC, centerR) + 1;
            
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    // Manhattan distance to center
                    const distance = Math.abs(c - centerC) + Math.abs(r - centerR);
                    const isActive = distance < maxDistance;
                    
                    const hue = (distance * 360) / maxDistance;
                    const saturation = 70 + Math.random() * 20;
                    const lightness = 50 + Math.random() * 10;
                    
                    bricks[c][r] = { 
                        x: 0, 
                        y: 0, 
                        status: isActive ? BRICK_NORMAL : 0,
                        color: `hsl(${hue}, ${saturation}%, ${lightness}%)`
                    };
                }
            }
        }

        // Random pattern
        function createRandomPattern() {
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    const isActive = Math.random() > 0.3; // 70% chance of being active
                    const hue = Math.random() * 360;
                    const saturation = 70 + Math.random() * 20;
                    const lightness = 50 + Math.random() * 10;
                    
                    bricks[c][r] = { 
                        x: 0, 
                        y: 0, 
                        status: isActive ? BRICK_NORMAL : 0,
                        color: `hsl(${hue}, ${saturation}%, ${lightness}%)`
                    };
                }
            }
        }

        // Zigzag pattern
        function createZigzagPattern() {
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    // Create a zigzag pattern
                    const isActive = (c + r) % 3 !== 1;
                    
                    const hue = (c * 360) / brickColumnCount;
                    const saturation = 70 + Math.random() * 20;
                    const lightness = 50 + Math.random() * 10;
                    
                    bricks[c][r] = { 
                        x: 0, 
                        y: 0, 
                        status: isActive ? BRICK_NORMAL : 0,
                        color: `hsl(${hue}, ${saturation}%, ${lightness}%)`
                    };
                }
            }
        }

        // Draw bricks
        function drawBricks() {
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    const brick = bricks[c][r];
                    if (brick.status > 0) { // Either normal or power-up brick
                        // Compute the brick position on screen
                        brick.x = c * (brickWidth + brickPadding) + brickOffsetLeft;
                        brick.y = r * (brickHeight + brickPadding) + brickOffsetTop;
                        
                        // Get base color for the brick
                        let baseColor = brick.color;
                        
                        // Create 3D effect with light and shadow
                        // Main brick face
                        ctx.beginPath();
                        ctx.rect(brick.x, brick.y, brickWidth, brickHeight);
                        ctx.fillStyle = baseColor;
                        ctx.fill();
                        ctx.closePath();
                        
                        // Create RGB color values for highlights and shadows
                        const rgb = getRGBfromColor(baseColor);
                        
                        // Top highlight (lighter)
                        ctx.beginPath();
                        ctx.moveTo(brick.x, brick.y);
                        ctx.lineTo(brick.x + brickWidth, brick.y);
                        ctx.lineTo(brick.x + brickWidth - 3, brick.y + 3);
                        ctx.lineTo(brick.x + 3, brick.y + 3);
                        ctx.closePath();
                        ctx.fillStyle = lightenColor(rgb, 50);
                        ctx.fill();
                        
                        // Left highlight (slightly lighter)
                        ctx.beginPath();
                        ctx.moveTo(brick.x, brick.y);
                        ctx.lineTo(brick.x, brick.y + brickHeight);
                        ctx.lineTo(brick.x + 3, brick.y + brickHeight - 3);
                        ctx.lineTo(brick.x + 3, brick.y + 3);
                        ctx.closePath();
                        ctx.fillStyle = lightenColor(rgb, 25);
                        ctx.fill();
                        
                        // Bottom shadow (darker)
                        ctx.beginPath();
                        ctx.moveTo(brick.x, brick.y + brickHeight);
                        ctx.lineTo(brick.x + brickWidth, brick.y + brickHeight);
                        ctx.lineTo(brick.x + brickWidth - 3, brick.y + brickHeight - 3);
                        ctx.lineTo(brick.x + 3, brick.y + brickHeight - 3);
                        ctx.closePath();
                        ctx.fillStyle = darkenColor(rgb, 50);
                        ctx.fill();
                        
                        // Right shadow (slightly darker)
                        ctx.beginPath();
                        ctx.moveTo(brick.x + brickWidth, brick.y);
                        ctx.lineTo(brick.x + brickWidth, brick.y + brickHeight);
                        ctx.lineTo(brick.x + brickWidth - 3, brick.y + brickHeight - 3);
                        ctx.lineTo(brick.x + brickWidth - 3, brick.y + 3);
                        ctx.closePath();
                        ctx.fillStyle = darkenColor(rgb, 25);
                        ctx.fill();
                        
                        // Add texture to main face
                        ctx.save();
                        ctx.clip();
                        // Create brick pattern with subtle lines
                        for (let i = 3; i < brickWidth - 3; i += 5) {
                            ctx.beginPath();
                            ctx.moveTo(brick.x + i, brick.y + 3);
                            ctx.lineTo(brick.x + i, brick.y + brickHeight - 3);
                            ctx.strokeStyle = darkenColor(rgb, 10);
                            ctx.lineWidth = 0.5;
                            ctx.stroke();
                            ctx.closePath();
                        }
                        
                        // Horizontal mortar lines
                        for (let j = 3; j < brickHeight - 3; j += 5) {
                            ctx.beginPath();
                            ctx.moveTo(brick.x + 3, brick.y + j);
                            ctx.lineTo(brick.x + brickWidth - 3, brick.y + j);
                            ctx.strokeStyle = darkenColor(rgb, 10);
                            ctx.lineWidth = 0.5;
                            ctx.stroke();
                            ctx.closePath();
                        }
                        ctx.restore();
                        
                        // Add sparkle effect for power-up bricks
                        if (brick.status === BRICK_POWER_UP || brick.status === BRICK_WIDE_PADDLE || brick.status === BRICK_LASER_POWER_UP) {
                            ctx.beginPath();
                            const sparkleX = brick.x + brickWidth / 2;
                            const sparkleY = brick.y + brickHeight / 2;
                            const sparkleSize = 5 + Math.sin(Date.now() / 200) * 2; // Pulsing effect
                            
                            // Draw sparkle
                            ctx.moveTo(sparkleX, sparkleY - sparkleSize);
                            ctx.lineTo(sparkleX + sparkleSize / 2, sparkleY - sparkleSize / 2);
                            ctx.lineTo(sparkleX + sparkleSize, sparkleY);
                            ctx.lineTo(sparkleX + sparkleSize / 2, sparkleY + sparkleSize / 2);
                            ctx.lineTo(sparkleX, sparkleY + sparkleSize);
                            ctx.lineTo(sparkleX - sparkleSize / 2, sparkleY + sparkleSize / 2);
                            ctx.lineTo(sparkleX - sparkleSize, sparkleY);
                            ctx.lineTo(sparkleX - sparkleSize / 2, sparkleY - sparkleSize / 2);
                            ctx.closePath();
                            
                            // Different colors for different power-up types
                            if (brick.status === BRICK_POWER_UP) {
                                ctx.fillStyle = "#FFFFFF"; // White for freeze ray
                            } else if (brick.status === BRICK_WIDE_PADDLE) {
                                ctx.fillStyle = "#FF88FF"; // Pink for wide paddle
                            } else if (brick.status === BRICK_LASER_POWER_UP) {
                                ctx.fillStyle = "#FFFF00"; // Bright yellow for laser (more visible over red)
                            }
                            ctx.fill();
                        }
                    }
                }
            }
        }

        // Helper function to lighten a color
        function lightenColor(rgb, amount) {
            return `rgb(${Math.min(rgb.r + amount, 255)}, ${Math.min(rgb.g + amount, 255)}, ${Math.min(rgb.b + amount, 255)})`;
        }

        // Helper function to darken a color
        function darkenColor(rgb, amount) {
            return `rgb(${Math.max(rgb.r - amount, 0)}, ${Math.max(rgb.g - amount, 0)}, ${Math.max(rgb.b - amount, 0)})`;
        }

        // Helper function to extract RGB components from any color format
        function getRGBfromColor(color) {
            // Create a temporary element to apply the color
            const temp = document.createElement('div');
            temp.style.color = color;
            document.body.appendChild(temp);
            
            // Get computed RGB values
            const style = window.getComputedStyle(temp).color;
            document.body.removeChild(temp);
            
            // Parse RGB values
            const match = style.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
            if (match) {
                return {
                    r: parseInt(match[1]),
                    g: parseInt(match[2]),
                    b: parseInt(match[3])
                };
            }
            
            // Fallback to default values if parsing fails
            return { r: 128, g: 128, b: 128 };
        }

        // Update checkBrickCollision function
        function checkBrickCollision(ball) {
            let bricksRemaining = false;
            
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    const brick = bricks[c][r];
                    if (brick.status > 0) {
                        bricksRemaining = true;
                        if (ball.x + ball.radius > brick.x && 
                            ball.x - ball.radius < brick.x + brickWidth &&
                            ball.y + ball.radius > brick.y && 
                            ball.y - ball.radius < brick.y + brickHeight) {
                            ball.dy = -ball.dy;
                            
                            // Check if this is a power-up brick
                            if (brick.status === BRICK_POWER_UP) {
                                // Give freeze ray power-up to player who hit the brick
                                const player = ball.lastHitBy;
                                const paddle = player === 1 ? paddle1 : paddle2;
                                paddle.hasFreezeRay = true;
                                
                                // Update power-up indicator
                                if (player === 1) {
                                    player1PowerUpIndicator.style.display = "block";
                                } else {
                                    player2PowerUpIndicator.style.display = "block";
                                }
                                
                                debug(`Player ${player} got freeze ray power-up!`);
                                soundFX.playPowerUp();
                            }
                            // Check if this is a wide paddle power-up brick
                            else if (brick.status === BRICK_WIDE_PADDLE) {
                    ctx.lineWidth = this.width;
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.x, this.y + this.height * this.progress);
                    ctx.stroke();
                    ctx.closePath();
                } else {
                    // Draw active ray
                    // Outer glow
                    ctx.beginPath();
                    ctx.strokeStyle = "#80FFFF";
                    ctx.lineWidth = this.width + 4;
                    ctx.globalAlpha = 0.5;
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.x, this.y + this.height * this.progress);
                    ctx.stroke();
                    ctx.closePath();
                    
                    // Inner beam
                    ctx.beginPath();
                    ctx.strokeStyle = "#00FFFF";
                    ctx.lineWidth = this.width;
                    ctx.globalAlpha = 1.0;
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.x, this.y + this.height * this.progress);
                    ctx.stroke();
                    ctx.closePath();
                    
                    // Tip effect (circular)
                    ctx.beginPath();
                    ctx.fillStyle = "#FFFFFF";
                    ctx.arc(this.x, this.y + this.height * this.progress, this.width + 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.closePath();
                }
                
                ctx.restore();
            }
        }

        // Class for laser beam
        class LaserBeam {
            constructor(x, y, player) {
                this.x = x;
                this.y = y;
                this.width = 20; // Wider than freeze ray
                this.height = player === 1 ? -canvas.height : canvas.height; // Negative for upward ray
                this.player = player; // Player who shot the ray
                this.speed = 20; // Faster than freeze ray
                this.active = true; // Whether ray is still active
                this.alphaValue = 1.0; // For fade-out animation
                this.hitTarget = false; // If ray hit the target
                this.progress = 0; // 0 to 1, how far the ray has traveled
                this.affectedBricks = []; // Track which bricks have been hit
            }
            
            update() {
                // Once ray hits, start fading
                if (this.hitTarget) {
                    this.alphaValue -= 0.05; // Fade out
                    if (this.alphaValue <= 0) {
                        this.active = false; // Remove ray when fully faded
                    }
                    return;
                }
                
                // Calculate ray progress (0 to 1)
                this.progress += this.speed / Math.abs(this.height);
                
                // Check for brick collisions as the laser travels
                this.checkBrickCollisions();
                
                // Check if ray reached the end
                if (this.progress >= 1) {
                    const targetPaddle = this.player === 1 ? paddle2 : paddle1;
                    const hitX = this.x;
                    
                    // Check if ray hit the paddle horizontally
                    if (hitX >= targetPaddle.x && hitX <= targetPaddle.x + targetPaddle.width) {
                        // Hit! Turn the paddle to ashes
                        targetPaddle.isAshes = true;
                        targetPaddle.ashesTimeRemaining = 10; // 10 seconds as ashes
                        debug(`Player ${this.player === 1 ? 2 : 1} turned to ashes for 10 seconds!`);
                        
                        this.hitTarget = true;
                        soundFX.playLaserHit(); // Instead of soundManager.play('laserHit')
                    } else {
                        debug(`Laser missed!`);
                        this.hitTarget = true;
                        soundFX.playMiss(); // Instead of soundManager.play('miss')
                    }
                }
            }
            
            checkBrickCollisions() {
                // Calculate current beam position
                                // Give wide paddle power-up to player who hit the brick
                                const player = ball.lastHitBy;
                                const paddle = player === 1 ? paddle1 : paddle2;
                                
                                // Apply wide paddle power-up
                                if (!paddle.isWide) {
                                    paddle.originalWidth = paddle.width; // Store original width
                                }
                                
                                // Calculate new width (100% wider - double size)
                                paddle.width = paddle.originalWidth * 2.0;
                                
                                // Keep paddle centered at the same position
                                paddle.x -= (paddle.width - paddle.originalWidth) / 2;
                                
                                // Set power-up status
                                paddle.isWide = true;
                                paddle.widePaddleTimeRemaining = 10; // 10 seconds duration
                                
                                debug(`Player ${player} got wide paddle power-up for 10 seconds!`);
                                soundFX.playPowerUp();
                            }
                            // Check if this is a laser power-up brick
                            else if (brick.status === BRICK_LASER_POWER_UP) {
                const startY = this.y;
                const endY = this.y + this.height * this.progress;
                const beamX = this.x;
                const beamWidth = this.width / 2;
                
                // Check all bricks for collisions with the beam
                for (let c = 0; c < brickColumnCount; c++) {
                    for (let r = 0; r < brickRowCount; r++) {
                        const brick = bricks[c][r];
                        if (brick.status > 0) {
                            // Check if brick is in the path of the laser beam
                            if (beamX + beamWidth > brick.x && beamX - beamWidth < brick.x + brickWidth) {
                                // For upward beam (player 1)
                                if (this.player === 1 && startY > brick.y && endY <= brick.y + brickHeight) {
                                    this.destroyBrick(c, r);
                                }
                                // For downward beam (player 2)
                                else if (this.player === 2 && startY < brick.y && endY >= brick.y) {
                                    this.destroyBrick(c, r);
                                }
                            }
                        }
                    }
                }
            }
            
            destroyBrick(c, r) {
                // Check if we've already processed this brick
                const brickKey = `${c},${r}`;
                if (this.affectedBricks.includes(brickKey)) {
                    return;
                }
                
                // Mark this brick as affected
                this.affectedBricks.push(brickKey);
                
                // Add points to the player who shot the laser
                if (this.player === 1) {
                    paddle1.score += 5;
                    debug(`Player 1 scored 5 points for lasering a brick`);
                } else {
                    paddle2.score += 5;
                    debug(`${gameMode === 1 ? 'AI' : 'Player 2'} scored 5 points for lasering a brick`);
                }
                
                // Create ash particles (more than regular brick breaking)
                createAshParticles(bricks[c][r], 30);
                
                // Destroy the brick
                bricks[c][r].status = 0;
                soundFX.playBrickBreak(); // Instead of soundManager.play('brickBreak')
                debug(`Brick at [${c},${r}] turned to ashes by laser`);
            }
            
            draw() {
                                // Give laser power-up to player who hit the brick
                                const player = ball.lastHitBy;
                                const paddle = player === 1 ? paddle1 : paddle2;
                                paddle.hasLaser = true;
                                
                                // Update laser indicator
                                if (player === 1) {
                                    player1LaserIndicator.style.display = "block";
                                } else {
                                    player2LaserIndicator.style.display = "block";
                                }
                                
                                debug(`Player ${player} got laser power-up!`);
                                soundFX.playPowerUp();
                            }
                            
                            brick.status = 0;
                ctx.save();
                
                if (this.hitTarget) {
                    // Draw fade out effect when hit
                    ctx.globalAlpha = this.alphaValue;
                    this.drawLaserBeam(this.progress);
                } else {
                    // Draw active laser beam
                    this.drawLaserBeam(this.progress);
                }
                
                ctx.restore();
            }
            
            drawLaserBeam(progress) {
                // Draw core beam (yellow)
                ctx.beginPath();
                ctx.strokeStyle = "#FFDD00";
                ctx.lineWidth = this.width * 0.4;
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x, this.y + this.height * progress);
                ctx.stroke();
                ctx.closePath();
                
                // Draw outer beam (red)
                ctx.beginPath();
                ctx.strokeStyle = "#FF4400";
                ctx.lineWidth = this.width;
                ctx.globalAlpha = 0.7;
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x, this.y + this.height * progress);
                ctx.stroke();
                ctx.closePath();
                
                // Draw impact point
                const impactY = this.y + this.height * progress;
                ctx.beginPath();
                ctx.fillStyle = "#FFFFFF";
                ctx.arc(this.x, impactY, this.width/2 + 5, 0, Math.PI * 2);
                ctx.globalAlpha = 0.8;
                ctx.fill();
                ctx.closePath();
                
                // Draw flame effects
                const numFlames = 5;
                for (let i = 0; i < numFlames; i++) {
                    const flameHeight = this.width * (0.5 + Math.random() * 0.5);
                    const flameWidth = this.width * (0.2 + Math.random() * 0.3);
                    const flameX = this.x + (Math.random() - 0.5) * this.width * 0.8;
                    const flameY = impactY + (this.player === 1 ? -flameHeight : 0);
                    
                    // Create gradient for flame
                    const gradient = ctx.createLinearGradient(flameX, flameY, flameX, flameY + (this.player === 1 ? -flameHeight : flameHeight));
                    gradient.addColorStop(0, "#FFFFFF");
                    gradient.addColorStop(0.3, "#FFDD00");
                    gradient.addColorStop(1, "#FF4400");
                    
                    ctx.beginPath();
                    ctx.fillStyle = gradient;
                    ctx.globalAlpha = 0.7 * this.alphaValue;
                    
                    // Draw flame shape
                    if (this.player === 1) {
                        // Upward flame
                        ctx.moveTo(flameX - flameWidth/2, flameY);
                        ctx.quadraticCurveTo(flameX - flameWidth/4, flameY - flameHeight/2, flameX, flameY - flameHeight);
                        ctx.quadraticCurveTo(flameX + flameWidth/4, flameY - flameHeight/2, flameX + flameWidth/2, flameY);
                    } else {
                        // Downward flame
                        ctx.moveTo(flameX - flameWidth/2, flameY);
                        ctx.quadraticCurveTo(flameX - flameWidth/4, flameY + flameHeight/2, flameX, flameY + flameHeight);
                        ctx.quadraticCurveTo(flameX + flameWidth/4, flameY + flameHeight/2, flameX + flameWidth/2, flameY);
                    }
                    
                    ctx.closePath();
                    ctx.fill();
                }
            }
        }

        // Update ball to be an array of two balls
        const balls = [
            {
                x: canvas.width / 2,
                y: canvas.height - 50, // Bottom player's ball
                radius: 8,
                dx: 2,
                dy: -2,
                owner: 1, // Player 1's ball
                lastHitBy: 1 // Track which player last hit the ball
            },
            {
                x: canvas.width / 2,
                y: 50, // Top player's ball
                radius: 8,
                dx: -2,
                dy: 2,
                owner: 2, // Player 2's ball
                lastHitBy: 2 // Track which player last hit the ball
            }
        ];

        // Brick configuration
        const brickRowCount = 3;
        const brickColumnCount = 8;
        const brickWidth = 75;
        const brickHeight = 20;
        const brickPadding = 10;
        const brickOffsetTop = canvas.height / 2 - (brickRowCount * (brickHeight + brickPadding)) / 2;
        const brickOffsetLeft = (canvas.width - (brickColumnCount * (brickWidth + brickPadding))) / 2;

        // Create bricks array
        const bricks = [];
        let currentPattern = 0; // Track the current pattern
        const BRICK_NORMAL = 1;
        const BRICK_POWER_UP = 2;
        const BRICK_WIDE_PADDLE = 3; // New constant for wide paddle power-up
        const BRICK_LASER_POWER_UP = 4; // New constant for laser power-up

        // Initialize bricks with different patterns
        function initBricks() {
            debug("Initializing bricks");
            
            // Clear existing bricks
            for (let c = 0; c < brickColumnCount; c++) {
                bricks[c] = [];
                for (let r = 0; r < brickRowCount; r++) {
                    bricks[c][r] = { status: 0 };
                }
            }
            
            // Choose a new pattern, different from the current one
            let newPattern;
            do {
                newPattern = Math.floor(Math.random() * 5); // 5 different patterns
            } while (newPattern === currentPattern && 5 > 1);
            
            currentPattern = newPattern;
            debug(`Selected brick pattern: ${currentPattern}`);
            
            // Apply the selected pattern
            switch (currentPattern) {
                case 0:
                    // Standard grid pattern
                    createStandardPattern();
                    break;
                case 1:
                    // Checkerboard pattern
                    createCheckerboardPattern();
                    break;
                case 2:
                    // Diamond pattern
                    createDiamondPattern();
                    break;
                case 3:
                    // Random pattern
                    createRandomPattern();
                    break;
                case 4:
                    // Zigzag pattern
                    createZigzagPattern();
                    break;
            }
            
            // Add power-up bricks (blue bricks)
            addPowerUpBricks();
            
            debug(`Created pattern with ${countActiveBricks()} active bricks`);
        }
        
        // Add some power-up bricks to the layout
        function addPowerUpBricks() {
            // Add 2-3 power-up bricks
            const numPowerUps = 2 + Math.floor(Math.random() * 2);
            let powerUpsAdded = 0;
            
            while (powerUpsAdded < numPowerUps) {
                const c = Math.floor(Math.random() * brickColumnCount);
                const r = Math.floor(Math.random() * brickRowCount);
                
                // Only convert active normal bricks to power-up bricks
                if (bricks[c][r].status === BRICK_NORMAL) {
                    bricks[c][r].status = BRICK_POWER_UP;
                    bricks[c][r].color = "#0088FF"; // Blue color for power-up bricks
                    powerUpsAdded++;
                    debug(`Added power-up brick at [${c},${r}]`);
                }
            }
            
            // Add 2-3 wide paddle power-up bricks (purple)
            const numWidePaddlePowerUps = 2 + Math.floor(Math.random() * 2);
            let widePaddlePowerUpsAdded = 0;
            
            while (widePaddlePowerUpsAdded < numWidePaddlePowerUps) {
                const c = Math.floor(Math.random() * brickColumnCount);
                const r = Math.floor(Math.random() * brickRowCount);
                
                // Only convert active normal bricks to wide paddle power-up bricks
                if (bricks[c][r].status === BRICK_NORMAL) {
                    bricks[c][r].status = BRICK_WIDE_PADDLE;
                    bricks[c][r].color = "#8800CC"; // Purple color for wide paddle power-up bricks
                    widePaddlePowerUpsAdded++;
                    debug(`Added wide paddle power-up brick at [${c},${r}]`);
                }
            }
            
            // Add 2-3 laser power-up bricks (red)
            const numLaserPowerUps = 2 + Math.floor(Math.random() * 2);
            let laserPowerUpsAdded = 0;
            
            while (laserPowerUpsAdded < numLaserPowerUps) {
                const c = Math.floor(Math.random() * brickColumnCount);
                const r = Math.floor(Math.random() * brickRowCount);
                
                // Only convert active normal bricks to laser power-up bricks
                if (bricks[c][r].status === BRICK_NORMAL) {
                    bricks[c][r].status = BRICK_LASER_POWER_UP;
                    bricks[c][r].color = "#FF3300"; // Red color for laser power-up bricks
                    laserPowerUpsAdded++;
                    debug(`Added laser power-up brick at [${c},${r}]`);
                }
            }
        }

        // Helper to count active bricks
        function countActiveBricks() {
            let count = 0;
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    if (bricks[c][r].status > 0) count++;
                }
            }
            return count;
        }

        // Standard grid pattern
        function createStandardPattern() {
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    const hue = (c * r * 360) / (brickColumnCount * brickRowCount);
                    const saturation = 70 + Math.random() * 20;
                    const lightness = 50 + Math.random() * 10;
                    bricks[c][r] = { 
                        x: 0, 
                        y: 0, 
                        status: BRICK_NORMAL,
                        color: `hsl(${hue}, ${saturation}%, ${lightness}%)`
                    };
                }
            }
        }

        // Checkerboard pattern
        function createCheckerboardPattern() {
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    const isActive = (c + r) % 2 === 0;
                    const hue = (c * r * 360) / (brickColumnCount * brickRowCount);
                    const saturation = 70 + Math.random() * 20;
                    const lightness = 50 + Math.random() * 10;
                    bricks[c][r] = { 
                        x: 0, 
                        y: 0, 
                        status: isActive ? BRICK_NORMAL : 0,
                        color: `hsl(${hue}, ${saturation}%, ${lightness}%)`
                    };
                }
            }
        }

        // Diamond pattern
        function createDiamondPattern() {
            const centerC = Math.floor(brickColumnCount / 2);
            const centerR = Math.floor(brickRowCount / 2);
            const maxDistance = Math.max(centerC, centerR) + 1;
            
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    // Manhattan distance to center
                    const distance = Math.abs(c - centerC) + Math.abs(r - centerR);
                    const isActive = distance < maxDistance;
                    
                    const hue = (distance * 360) / maxDistance;
                    const saturation = 70 + Math.random() * 20;
                    const lightness = 50 + Math.random() * 10;
                    
                    bricks[c][r] = { 
                        x: 0, 
                        y: 0, 
                        status: isActive ? BRICK_NORMAL : 0,
                        color: `hsl(${hue}, ${saturation}%, ${lightness}%)`
                    };
                }
            }
        }

        // Random pattern
        function createRandomPattern() {
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    const isActive = Math.random() > 0.3; // 70% chance of being active
                    const hue = Math.random() * 360;
                    const saturation = 70 + Math.random() * 20;
                    const lightness = 50 + Math.random() * 10;
                    
                    bricks[c][r] = { 
                        x: 0, 
                        y: 0, 
                        status: isActive ? BRICK_NORMAL : 0,
                        color: `hsl(${hue}, ${saturation}%, ${lightness}%)`
                    };
                }
            }
        }

        // Zigzag pattern
        function createZigzagPattern() {
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    // Create a zigzag pattern
                    const isActive = (c + r) % 3 !== 1;
                    
                    const hue = (c * 360) / brickColumnCount;
                    const saturation = 70 + Math.random() * 20;
                    const lightness = 50 + Math.random() * 10;
                    
                    bricks[c][r] = { 
                        x: 0, 
                        y: 0, 
                        status: isActive ? BRICK_NORMAL : 0,
                        color: `hsl(${hue}, ${saturation}%, ${lightness}%)`
                    };
                }
            }
        }

        // Draw bricks
        function drawBricks() {
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    const brick = bricks[c][r];
                    if (brick.status > 0) { // Either normal or power-up brick
                        // Compute the brick position on screen
                        brick.x = c * (brickWidth + brickPadding) + brickOffsetLeft;
                        brick.y = r * (brickHeight + brickPadding) + brickOffsetTop;
                        
                        // Get base color for the brick
                        let baseColor = brick.color;
                        
                        // Create 3D effect with light and shadow
                        // Main brick face
                        ctx.beginPath();
                        ctx.rect(brick.x, brick.y, brickWidth, brickHeight);
                        ctx.fillStyle = baseColor;
                        ctx.fill();
                        ctx.closePath();
                        
                        // Create RGB color values for highlights and shadows
                        const rgb = getRGBfromColor(baseColor);
                        
                        // Top highlight (lighter)
                        ctx.beginPath();
                        ctx.moveTo(brick.x, brick.y);
                        ctx.lineTo(brick.x + brickWidth, brick.y);
                        ctx.lineTo(brick.x + brickWidth - 3, brick.y + 3);
                        ctx.lineTo(brick.x + 3, brick.y + 3);
                        ctx.closePath();
                        ctx.fillStyle = lightenColor(rgb, 50);
                        ctx.fill();
                        
                        // Left highlight (slightly lighter)
                        ctx.beginPath();
                        ctx.moveTo(brick.x, brick.y);
                        ctx.lineTo(brick.x, brick.y + brickHeight);
                        ctx.lineTo(brick.x + 3, brick.y + brickHeight - 3);
                        ctx.lineTo(brick.x + 3, brick.y + 3);
                        ctx.closePath();
                        ctx.fillStyle = lightenColor(rgb, 25);
                        ctx.fill();
                        
                        // Bottom shadow (darker)
                        ctx.beginPath();
                        ctx.moveTo(brick.x, brick.y + brickHeight);
                        ctx.lineTo(brick.x + brickWidth, brick.y + brickHeight);
                        ctx.lineTo(brick.x + brickWidth - 3, brick.y + brickHeight - 3);
                        ctx.lineTo(brick.x + 3, brick.y + brickHeight - 3);
                        ctx.closePath();
                        ctx.fillStyle = darkenColor(rgb, 50);
                        ctx.fill();
                        
                        // Right shadow (slightly darker)
                        ctx.beginPath();
                        ctx.moveTo(brick.x + brickWidth, brick.y);
                        ctx.lineTo(brick.x + brickWidth, brick.y + brickHeight);
                        ctx.lineTo(brick.x + brickWidth - 3, brick.y + brickHeight - 3);
                        ctx.lineTo(brick.x + brickWidth - 3, brick.y + 3);
                        ctx.closePath();
                        ctx.fillStyle = darkenColor(rgb, 25);
                        ctx.fill();
                        
                        // Add texture to main face
                        ctx.save();
                        ctx.clip();
                        // Create brick pattern with subtle lines
                        for (let i = 3; i < brickWidth - 3; i += 5) {
                            ctx.beginPath();
                            ctx.moveTo(brick.x + i, brick.y + 3);
                            ctx.lineTo(brick.x + i, brick.y + brickHeight - 3);
                            ctx.strokeStyle = darkenColor(rgb, 10);
                            ctx.lineWidth = 0.5;
                            ctx.stroke();
                            ctx.closePath();
                        }
                        
                        // Horizontal mortar lines
                        for (let j = 3; j < brickHeight - 3; j += 5) {
                            ctx.beginPath();
                            ctx.moveTo(brick.x + 3, brick.y + j);
                            ctx.lineTo(brick.x + brickWidth - 3, brick.y + j);
                            ctx.strokeStyle = darkenColor(rgb, 10);
                            ctx.lineWidth = 0.5;
                            ctx.stroke();
                            ctx.closePath();
                        }
                        ctx.restore();
                        
                        // Add sparkle effect for power-up bricks
                        if (brick.status === BRICK_POWER_UP || brick.status === BRICK_WIDE_PADDLE || brick.status === BRICK_LASER_POWER_UP) {
                            ctx.beginPath();
                            const sparkleX = brick.x + brickWidth / 2;
                            const sparkleY = brick.y + brickHeight / 2;
                            const sparkleSize = 5 + Math.sin(Date.now() / 200) * 2; // Pulsing effect
                            
                            // Draw sparkle
                            ctx.moveTo(sparkleX, sparkleY - sparkleSize);
                            ctx.lineTo(sparkleX + sparkleSize / 2, sparkleY - sparkleSize / 2);
                            ctx.lineTo(sparkleX + sparkleSize, sparkleY);
                            ctx.lineTo(sparkleX + sparkleSize / 2, sparkleY + sparkleSize / 2);
                            ctx.lineTo(sparkleX, sparkleY + sparkleSize);
                            ctx.lineTo(sparkleX - sparkleSize / 2, sparkleY + sparkleSize / 2);
                            ctx.lineTo(sparkleX - sparkleSize, sparkleY);
                            ctx.lineTo(sparkleX - sparkleSize / 2, sparkleY - sparkleSize / 2);
                            ctx.closePath();
                            
                            // Different colors for different power-up types
                            if (brick.status === BRICK_POWER_UP) {
                                ctx.fillStyle = "#FFFFFF"; // White for freeze ray
                            } else if (brick.status === BRICK_WIDE_PADDLE) {
                                ctx.fillStyle = "#FF88FF"; // Pink for wide paddle
                            } else if (brick.status === BRICK_LASER_POWER_UP) {
                                ctx.fillStyle = "#FFFF00"; // Bright yellow for laser (more visible over red)
                            }
                            ctx.fill();
                        }
                    }
                }
            }
        }

        // Helper function to lighten a color
        function lightenColor(rgb, amount) {
            return `rgb(${Math.min(rgb.r + amount, 255)}, ${Math.min(rgb.g + amount, 255)}, ${Math.min(rgb.b + amount, 255)})`;
        }

        // Helper function to darken a color
        function darkenColor(rgb, amount) {
            return `rgb(${Math.max(rgb.r - amount, 0)}, ${Math.max(rgb.g - amount, 0)}, ${Math.max(rgb.b - amount, 0)})`;
        }

        // Helper function to extract RGB components from any color format
        function getRGBfromColor(color) {
            // Create a temporary element to apply the color
            const temp = document.createElement('div');
            temp.style.color = color;
            document.body.appendChild(temp);
            
            // Get computed RGB values
            const style = window.getComputedStyle(temp).color;
            document.body.removeChild(temp);
            
            // Parse RGB values
            const match = style.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
            if (match) {
                return {
                    r: parseInt(match[1]),
                    g: parseInt(match[2]),
                    b: parseInt(match[3])
                };
            }
            
            // Fallback to default values if parsing fails
            return { r: 128, g: 128, b: 128 };
        }

        // Update checkBrickCollision function
        function checkBrickCollision(ball) {
            let bricksRemaining = false;
            
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    const brick = bricks[c][r];
                    if (brick.status > 0) {
                        bricksRemaining = true;
                        if (ball.x + ball.radius > brick.x && 
                            ball.x - ball.radius < brick.x + brickWidth &&
                            ball.y + ball.radius > brick.y && 
                            ball.y - ball.radius < brick.y + brickHeight) {
                            ball.dy = -ball.dy;
                            
                            // Check if this is a power-up brick
                            if (brick.status === BRICK_POWER_UP) {
                                // Give freeze ray power-up to player who hit the brick
                                const player = ball.lastHitBy;
                                const paddle = player === 1 ? paddle1 : paddle2;
                                paddle.hasFreezeRay = true;
                                
                                // Update power-up indicator
                                if (player === 1) {
                                    player1PowerUpIndicator.style.display = "block";
                                } else {
                                    player2PowerUpIndicator.style.display = "block";
                                }
                                
                                debug(`Player ${player} got freeze ray power-up!`);
                                soundFX.playPowerUp();
                            }
                            // Check if this is a wide paddle power-up brick
                            else if (brick.status === BRICK_WIDE_PADDLE) {
                    ctx.lineWidth = this.width;
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.x, this.y + this.height * this.progress);
                    ctx.stroke();
                    ctx.closePath();
                } else {
                    // Draw active ray
                    // Outer glow
                    ctx.beginPath();
                    ctx.strokeStyle = "#80FFFF";
                    ctx.lineWidth = this.width + 4;
                    ctx.globalAlpha = 0.5;
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.x, this.y + this.height * this.progress);
                    ctx.stroke();
                    ctx.closePath();
                    
                    // Inner beam
                    ctx.beginPath();
                    ctx.strokeStyle = "#00FFFF";
                    ctx.lineWidth = this.width;
                    ctx.globalAlpha = 1.0;
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.x, this.y + this.height * this.progress);
                    ctx.stroke();
                    ctx.closePath();
                    
                    // Tip effect (circular)
                    ctx.beginPath();
                    ctx.fillStyle = "#FFFFFF";
                    ctx.arc(this.x, this.y + this.height * this.progress, this.width + 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.closePath();
                }
                
                ctx.restore();
            }
        }

        // Class for laser beam
        class LaserBeam {
            constructor(x, y, player) {
                this.x = x;
                this.y = y;
                this.width = 20; // Wider than freeze ray
                this.height = player === 1 ? -canvas.height : canvas.height; // Negative for upward ray
                this.player = player; // Player who shot the ray
                this.speed = 20; // Faster than freeze ray
                this.active = true; // Whether ray is still active
                this.alphaValue = 1.0; // For fade-out animation
                this.hitTarget = false; // If ray hit the target
                this.progress = 0; // 0 to 1, how far the ray has traveled
                this.affectedBricks = []; // Track which bricks have been hit
            }
            
            update() {
                // Once ray hits, start fading
                if (this.hitTarget) {
                    this.alphaValue -= 0.05; // Fade out
                    if (this.alphaValue <= 0) {
                        this.active = false; // Remove ray when fully faded
                    }
                    return;
                }
                
                // Calculate ray progress (0 to 1)
                this.progress += this.speed / Math.abs(this.height);
                
                // Check for brick collisions as the laser travels
                this.checkBrickCollisions();
                
                // Check if ray reached the end
                if (this.progress >= 1) {
                    const targetPaddle = this.player === 1 ? paddle2 : paddle1;
                    const hitX = this.x;
                    
                    // Check if ray hit the paddle horizontally
                    if (hitX >= targetPaddle.x && hitX <= targetPaddle.x + targetPaddle.width) {
                        // Hit! Turn the paddle to ashes
                        targetPaddle.isAshes = true;
                        targetPaddle.ashesTimeRemaining = 10; // 10 seconds as ashes
                        debug(`Player ${this.player === 1 ? 2 : 1} turned to ashes for 10 seconds!`);
                        
                        this.hitTarget = true;
                        soundFX.playLaserHit(); // Instead of soundManager.play('laserHit')
                    } else {
                        debug(`Laser missed!`);
                        this.hitTarget = true;
                        soundFX.playMiss(); // Instead of soundManager.play('miss')
                    }
                }
            }
            
            checkBrickCollisions() {
                // Calculate current beam position
                                // Give wide paddle power-up to player who hit the brick
                                const player = ball.lastHitBy;
                                const paddle = player === 1 ? paddle1 : paddle2;
                                
                                // Apply wide paddle power-up
                                if (!paddle.isWide) {
                                    paddle.originalWidth = paddle.width; // Store original width
                                }
                                
                                // Calculate new width (100% wider - double size)
                                paddle.width = paddle.originalWidth * 2.0;
                                
                                // Keep paddle centered at the same position
                                paddle.x -= (paddle.width - paddle.originalWidth) / 2;
                                
                                // Set power-up status
                                paddle.isWide = true;
                                paddle.widePaddleTimeRemaining = 10; // 10 seconds duration
                                
                                debug(`Player ${player} got wide paddle power-up for 10 seconds!`);
                                soundFX.playPowerUp();
                            }
                            // Check if this is a laser power-up brick
                            else if (brick.status === BRICK_LASER_POWER_UP) {
                const startY = this.y;
                const endY = this.y + this.height * this.progress;
                const beamX = this.x;
                const beamWidth = this.width / 2;
                
                // Check all bricks for collisions with the beam
                for (let c = 0; c < brickColumnCount; c++) {
                    for (let r = 0; r < brickRowCount; r++) {
                        const brick = bricks[c][r];
                        if (brick.status > 0) {
                            // Check if brick is in the path of the laser beam
                            if (beamX + beamWidth > brick.x && beamX - beamWidth < brick.x + brickWidth) {
                                // For upward beam (player 1)
                                if (this.player === 1 && startY > brick.y && endY <= brick.y + brickHeight) {
                                    this.destroyBrick(c, r);
                                }
                                // For downward beam (player 2)
                                else if (this.player === 2 && startY < brick.y && endY >= brick.y) {
                                    this.destroyBrick(c, r);
                                }
                            }
                        }
                    }
                }
            }
            
            destroyBrick(c, r) {
                // Check if we've already processed this brick
                const brickKey = `${c},${r}`;
                if (this.affectedBricks.includes(brickKey)) {
                    return;
                }
                
                // Mark this brick as affected
                this.affectedBricks.push(brickKey);
                
                // Add points to the player who shot the laser
                if (this.player === 1) {
                    paddle1.score += 5;
                    debug(`Player 1 scored 5 points for lasering a brick`);
                } else {
                    paddle2.score += 5;
                    debug(`${gameMode === 1 ? 'AI' : 'Player 2'} scored 5 points for lasering a brick`);
                }
                
                // Create ash particles (more than regular brick breaking)
                createAshParticles(bricks[c][r], 30);
                
                // Destroy the brick
                bricks[c][r].status = 0;
                soundFX.playBrickBreak(); // Instead of soundManager.play('brickBreak')
                debug(`Brick at [${c},${r}] turned to ashes by laser`);
            }
            
            draw() {
                                // Give laser power-up to player who hit the brick
                                const player = ball.lastHitBy;
                                const paddle = player === 1 ? paddle1 : paddle2;
                                paddle.hasLaser = true;
                                
                                // Update laser indicator
                                if (player === 1) {
                                    player1LaserIndicator.style.display = "block";
                                } else {
                                    player2LaserIndicator.style.display = "block";
                                }
                                
                                debug(`Player ${player} got laser power-up!`);
                                soundFX.playPowerUp();
                            }
                            
                            brick.status = 0;
                ctx.save();
                
                if (this.hitTarget) {
                    // Draw fade out effect when hit
                    ctx.globalAlpha = this.alphaValue;
                    this.drawLaserBeam(this.progress);
                } else {
                    // Draw active laser beam
                    this.drawLaserBeam(this.progress);
                }
                
                ctx.restore();
            }
            
            drawLaserBeam(progress) {
                // Draw core beam (yellow)
                ctx.beginPath();
                ctx.strokeStyle = "#FFDD00";
                ctx.lineWidth = this.width * 0.4;
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x, this.y + this.height * progress);
                ctx.stroke();
                ctx.closePath();
                
                // Draw outer beam (red)
                ctx.beginPath();
                ctx.strokeStyle = "#FF4400";
                ctx.lineWidth = this.width;
                ctx.globalAlpha = 0.7;
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x, this.y + this.height * progress);
                ctx.stroke();
                ctx.closePath();
                
                // Draw impact point
                const impactY = this.y + this.height * progress;
                ctx.beginPath();
                ctx.fillStyle = "#FFFFFF";
                ctx.arc(this.x, impactY, this.width/2 + 5, 0, Math.PI * 2);
                ctx.globalAlpha = 0.8;
                ctx.fill();
                ctx.closePath();
                
                // Draw flame effects
                const numFlames = 5;
                for (let i = 0; i < numFlames; i++) {
                    const flameHeight = this.width * (0.5 + Math.random() * 0.5);
                    const flameWidth = this.width * (0.2 + Math.random() * 0.3);
                    const flameX = this.x + (Math.random() - 0.5) * this.width * 0.8;
                    const flameY = impactY + (this.player === 1 ? -flameHeight : 0);
                    
                    // Create gradient for flame
                    const gradient = ctx.createLinearGradient(flameX, flameY, flameX, flameY + (this.player === 1 ? -flameHeight : flameHeight));
                    gradient.addColorStop(0, "#FFFFFF");
                    gradient.addColorStop(0.3, "#FFDD00");
                    gradient.addColorStop(1, "#FF4400");
                    
                    ctx.beginPath();
                    ctx.fillStyle = gradient;
                    ctx.globalAlpha = 0.7 * this.alphaValue;
                    
                    // Draw flame shape
                    if (this.player === 1) {
                        // Upward flame
                        ctx.moveTo(flameX - flameWidth/2, flameY);
                        ctx.quadraticCurveTo(flameX - flameWidth/4, flameY - flameHeight/2, flameX, flameY - flameHeight);
                        ctx.quadraticCurveTo(flameX + flameWidth/4, flameY - flameHeight/2, flameX + flameWidth/2, flameY);
                    } else {
                        // Downward flame
                        ctx.moveTo(flameX - flameWidth/2, flameY);
                        ctx.quadraticCurveTo(flameX - flameWidth/4, flameY + flameHeight/2, flameX, flameY + flameHeight);
                        ctx.quadraticCurveTo(flameX + flameWidth/4, flameY + flameHeight/2, flameX + flameWidth/2, flameY);
                    }
                    
                    ctx.closePath();
                    ctx.fill();
                }
            }
        }

        // Update ball to be an array of two balls
        const balls = [
            {
                x: canvas.width / 2,
                y: canvas.height - 50, // Bottom player's ball
                radius: 8,
                dx: 2,
                dy: -2,
                owner: 1, // Player 1's ball
                lastHitBy: 1 // Track which player last hit the ball
            },
            {
                x: canvas.width / 2,
                y: 50, // Top player's ball
                radius: 8,
                dx: -2,
                dy: 2,
                owner: 2, // Player 2's ball
                lastHitBy: 2 // Track which player last hit the ball
            }
        ];

        // Brick configuration
        const brickRowCount = 3;
        const brickColumnCount = 8;
        const brickWidth = 75;
        const brickHeight = 20;
        const brickPadding = 10;
        const brickOffsetTop = canvas.height / 2 - (brickRowCount * (brickHeight + brickPadding)) / 2;
        const brickOffsetLeft = (canvas.width - (brickColumnCount * (brickWidth + brickPadding))) / 2;

        // Create bricks array
        const bricks = [];
        let currentPattern = 0; // Track the current pattern
        const BRICK_NORMAL = 1;
        const BRICK_POWER_UP = 2;
        const BRICK_WIDE_PADDLE = 3; // New constant for wide paddle power-up
        const BRICK_LASER_POWER_UP = 4; // New constant for laser power-up

        // Initialize bricks with different patterns
        function initBricks() {
            debug("Initializing bricks");
            
            // Clear existing bricks
            for (let c = 0; c < brickColumnCount; c++) {
                bricks[c] = [];
                for (let r = 0; r < brickRowCount; r++) {
                    bricks[c][r] = { status: 0 };
                }
            }
            
            // Choose a new pattern, different from the current one
            let newPattern;
            do {
                newPattern = Math.floor(Math.random() * 5); // 5 different patterns
            } while (newPattern === currentPattern && 5 > 1);
            
            currentPattern = newPattern;
            debug(`Selected brick pattern: ${currentPattern}`);
            
            // Apply the selected pattern
            switch (currentPattern) {
                case 0:
                    // Standard grid pattern
                    createStandardPattern();
                    break;
                case 1:
                    // Checkerboard pattern
                    createCheckerboardPattern();
                    break;
                case 2:
                    // Diamond pattern
                    createDiamondPattern();
                    break;
                case 3:
                    // Random pattern
                    createRandomPattern();
                    break;
                case 4:
                    // Zigzag pattern
                    createZigzagPattern();
                    break;
            }
            
            // Add power-up bricks (blue bricks)
            addPowerUpBricks();
            
            debug(`Created pattern with ${countActiveBricks()} active bricks`);
        }
        
        // Add some power-up bricks to the layout
        function addPowerUpBricks() {
            // Add 2-3 power-up bricks
            const numPowerUps = 2 + Math.floor(Math.random() * 2);
            let powerUpsAdded = 0;
            
            while (powerUpsAdded < numPowerUps) {
                const c = Math.floor(Math.random() * brickColumnCount);
                const r = Math.floor(Math.random() * brickRowCount);
                
                // Only convert active normal bricks to power-up bricks
                if (bricks[c][r].status === BRICK_NORMAL) {
                    bricks[c][r].status = BRICK_POWER_UP;
                    bricks[c][r].color = "#0088FF"; // Blue color for power-up bricks
                    powerUpsAdded++;
                    debug(`Added power-up brick at [${c},${r}]`);
                }
            }
            
            // Add 2-3 wide paddle power-up bricks (purple)
            const numWidePaddlePowerUps = 2 + Math.floor(Math.random() * 2);
            let widePaddlePowerUpsAdded = 0;
            
            while (widePaddlePowerUpsAdded < numWidePaddlePowerUps) {
                const c = Math.floor(Math.random() * brickColumnCount);
                const r = Math.floor(Math.random() * brickRowCount);
                
                // Only convert active normal bricks to wide paddle power-up bricks
                if (bricks[c][r].status === BRICK_NORMAL) {
                    bricks[c][r].status = BRICK_WIDE_PADDLE;
                    bricks[c][r].color = "#8800CC"; // Purple color for wide paddle power-up bricks
                    widePaddlePowerUpsAdded++;
                    debug(`Added wide paddle power-up brick at [${c},${r}]`);
                }
            }
            
            // Add 2-3 laser power-up bricks (red)
            const numLaserPowerUps = 2 + Math.floor(Math.random() * 2);
            let laserPowerUpsAdded = 0;
            
            while (laserPowerUpsAdded < numLaserPowerUps) {
                const c = Math.floor(Math.random() * brickColumnCount);
                const r = Math.floor(Math.random() * brickRowCount);
                
                // Only convert active normal bricks to laser power-up bricks
                if (bricks[c][r].status === BRICK_NORMAL) {
                    bricks[c][r].status = BRICK_LASER_POWER_UP;
                    bricks[c][r].color = "#FF3300"; // Red color for laser power-up bricks
                    laserPowerUpsAdded++;
                    debug(`Added laser power-up brick at [${c},${r}]`);
                }
            }
        }

        // Helper to count active bricks
        function countActiveBricks() {
            let count = 0;
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    if (bricks[c][r].status > 0) count++;
                }
            }
            return count;
        }

        // Standard grid pattern
        function createStandardPattern() {
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    const hue = (c * r * 360) / (brickColumnCount * brickRowCount);
                    const saturation = 70 + Math.random() * 20;
                    const lightness = 50 + Math.random() * 10;
                    bricks[c][r] = { 
                        x: 0, 
                        y: 0, 
                        status: BRICK_NORMAL,
                        color: `hsl(${hue}, ${saturation}%, ${lightness}%)`
                    };
                }
            }
        }

        // Checkerboard pattern
        function createCheckerboardPattern() {
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    const isActive = (c + r) % 2 === 0;
                    const hue = (c * r * 360) / (brickColumnCount * brickRowCount);
                    const saturation = 70 + Math.random() * 20;
                    const lightness = 50 + Math.random() * 10;
                    bricks[c][r] = { 
                        x: 0, 
                        y: 0, 
                        status: isActive ? BRICK_NORMAL : 0,
                        color: `hsl(${hue}, ${saturation}%, ${lightness}%)`
                    };
                }
            }
        }

        // Diamond pattern
        function createDiamondPattern() {
            const centerC = Math.floor(brickColumnCount / 2);
            const centerR = Math.floor(brickRowCount / 2);
            const maxDistance = Math.max(centerC, centerR) + 1;
            
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    // Manhattan distance to center
                    const distance = Math.abs(c - centerC) + Math.abs(r - centerR);
                    const isActive = distance < maxDistance;
                    
                    const hue = (distance * 360) / maxDistance;
                    const saturation = 70 + Math.random() * 20;
                    const lightness = 50 + Math.random() * 10;
                    
                    bricks[c][r] = { 
                        x: 0, 
                        y: 0, 
                        status: isActive ? BRICK_NORMAL : 0,
                        color: `hsl(${hue}, ${saturation}%, ${lightness}%)`
                    };
                }
            }
        }

        // Random pattern
        function createRandomPattern() {
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    const isActive = Math.random() > 0.3; // 70% chance of being active
                    const hue = Math.random() * 360;
                    const saturation = 70 + Math.random() * 20;
                    const lightness = 50 + Math.random() * 10;
                    
                    bricks[c][r] = { 
                        x: 0, 
                        y: 0, 
                        status: isActive ? BRICK_NORMAL : 0,
                        color: `hsl(${hue}, ${saturation}%, ${lightness}%)`
                    };
                }
            }
        }

        // Zigzag pattern
        function createZigzagPattern() {
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    // Create a zigzag pattern
                    const isActive = (c + r) % 3 !== 1;
                    
                    const hue = (c * 360) / brickColumnCount;
                    const saturation = 70 + Math.random() * 20;
                    const lightness = 50 + Math.random() * 10;
                    
                    bricks[c][r] = { 
                        x: 0, 
                        y: 0, 
                        status: isActive ? BRICK_NORMAL : 0,
                        color: `hsl(${hue}, ${saturation}%, ${lightness}%)`
                    };
                }
            }
        }

        // Draw bricks
        function drawBricks() {
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    const brick = bricks[c][r];
                    if (brick.status > 0) { // Either normal or power-up brick
                        // Compute the brick position on screen
                        brick.x = c * (brickWidth + brickPadding) + brickOffsetLeft;
                        brick.y = r * (brickHeight + brickPadding) + brickOffsetTop;
                        
                        // Get base color for the brick
                        let baseColor = brick.color;
                        
                        // Create 3D effect with light and shadow
                        // Main brick face
                        ctx.beginPath();
                        ctx.rect(brick.x, brick.y, brickWidth, brickHeight);
                        ctx.fillStyle = baseColor;
                        ctx.fill();
                        ctx.closePath();
                        
                        // Create RGB color values for highlights and shadows
                        const rgb = getRGBfromColor(baseColor);
                        
                        // Top highlight (lighter)
                        ctx.beginPath();
                        ctx.moveTo(brick.x, brick.y);
                        ctx.lineTo(brick.x + brickWidth, brick.y);
                        ctx.lineTo(brick.x + brickWidth - 3, brick.y + 3);
                        ctx.lineTo(brick.x + 3, brick.y + 3);
                        ctx.closePath();
                        ctx.fillStyle = lightenColor(rgb, 50);
                        ctx.fill();
                        
                        // Left highlight (slightly lighter)
                        ctx.beginPath();
                        ctx.moveTo(brick.x, brick.y);
                        ctx.lineTo(brick.x, brick.y + brickHeight);
                        ctx.lineTo(brick.x + 3, brick.y + brickHeight - 3);
                        ctx.lineTo(brick.x + 3, brick.y + 3);
                        ctx.closePath();
                        ctx.fillStyle = lightenColor(rgb, 25);
                        ctx.fill();
                        
                        // Bottom shadow (darker)
                        ctx.beginPath();
                        ctx.moveTo(brick.x, brick.y + brickHeight);
                        ctx.lineTo(brick.x + brickWidth, brick.y + brickHeight);
                        ctx.lineTo(brick.x + brickWidth - 3, brick.y + brickHeight - 3);
                        ctx.lineTo(brick.x + 3, brick.y + brickHeight - 3);
                        ctx.closePath();
                        ctx.fillStyle = darkenColor(rgb, 50);
                        ctx.fill();
                        
                        // Right shadow (slightly darker)
                        ctx.beginPath();
                        ctx.moveTo(brick.x + brickWidth, brick.y);
                        ctx.lineTo(brick.x + brickWidth, brick.y + brickHeight);
                        ctx.lineTo(brick.x + brickWidth - 3, brick.y + brickHeight - 3);
                        ctx.lineTo(brick.x + brickWidth - 3, brick.y + 3);
                        ctx.closePath();
                        ctx.fillStyle = darkenColor(rgb, 25);
                        ctx.fill();
                        
                        // Add texture to main face
                        ctx.save();
                        ctx.clip();
                        // Create brick pattern with subtle lines
                        for (let i = 3; i < brickWidth - 3; i += 5) {
                            ctx.beginPath();
                            ctx.moveTo(brick.x + i, brick.y + 3);
                            ctx.lineTo(brick.x + i, brick.y + brickHeight - 3);
                            ctx.strokeStyle = darkenColor(rgb, 10);
                            ctx.lineWidth = 0.5;
                            ctx.stroke();
                            ctx.closePath();
                        }
                        
                        // Horizontal mortar lines
                        for (let j = 3; j < brickHeight - 3; j += 5) {
                            ctx.beginPath();
                            ctx.moveTo(brick.x + 3, brick.y + j);
                            ctx.lineTo(brick.x + brickWidth - 3, brick.y + j);
                            ctx.strokeStyle = darkenColor(rgb, 10);
                            ctx.lineWidth = 0.5;
                            ctx.stroke();
                            ctx.closePath();
                        }
                        ctx.restore();
                        
                        // Add sparkle effect for power-up bricks
                        if (brick.status === BRICK_POWER_UP || brick.status === BRICK_WIDE_PADDLE || brick.status === BRICK_LASER_POWER_UP) {
                            ctx.beginPath();
                            const sparkleX = brick.x + brickWidth / 2;
                            const sparkleY = brick.y + brickHeight / 2;
                            const sparkleSize = 5 + Math.sin(Date.now() / 200) * 2; // Pulsing effect
                            
                            // Draw sparkle
                            ctx.moveTo(sparkleX, sparkleY - sparkleSize);
                            ctx.lineTo(sparkleX + sparkleSize / 2, sparkleY - sparkleSize / 2);
                            ctx.lineTo(sparkleX + sparkleSize, sparkleY);
                            ctx.lineTo(sparkleX + sparkleSize / 2, sparkleY + sparkleSize / 2);
                            ctx.lineTo(sparkleX, sparkleY + sparkleSize);
                            ctx.lineTo(sparkleX - sparkleSize / 2, sparkleY + sparkleSize / 2);
                            ctx.lineTo(sparkleX - sparkleSize, sparkleY);
                            ctx.lineTo(sparkleX - sparkleSize / 2, sparkleY - sparkleSize / 2);
                            ctx.closePath();
                            
                            // Different colors for different power-up types
                            if (brick.status === BRICK_POWER_UP) {
                                ctx.fillStyle = "#FFFFFF"; // White for freeze ray
                            } else if (brick.status === BRICK_WIDE_PADDLE) {
                                ctx.fillStyle = "#FF88FF"; // Pink for wide paddle
                            } else if (brick.status === BRICK_LASER_POWER_UP) {
                                ctx.fillStyle = "#FFFF00"; // Bright yellow for laser (more visible over red)
                            }
                            ctx.fill();
                        }
                    }
                }
            }
        }

        // Helper function to lighten a color
        function lightenColor(rgb, amount) {
            return `rgb(${Math.min(rgb.r + amount, 255)}, ${Math.min(rgb.g + amount, 255)}, ${Math.min(rgb.b + amount, 255)})`;
        }

        // Helper function to darken a color
        function darkenColor(rgb, amount) {
            return `rgb(${Math.max(rgb.r - amount, 0)}, ${Math.max(rgb.g - amount, 0)}, ${Math.max(rgb.b - amount, 0)})`;
        }

        // Helper function to extract RGB components from any color format
        function getRGBfromColor(color) {
            // Create a temporary element to apply the color
            const temp = document.createElement('div');
            temp.style.color = color;
            document.body.appendChild(temp);
            
            // Get computed RGB values
            const style = window.getComputedStyle(temp).color;
            document.body.removeChild(temp);
            
            // Parse RGB values
            const match = style.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
            if (match) {
                return {
                    r: parseInt(match[1]),
                    g: parseInt(match[2]),
                    b: parseInt(match[3])
                };
            }
            
            // Fallback to default values if parsing fails
            return { r: 128, g: 128, b: 128 };
        }

        // Update checkBrickCollision function
        function checkBrickCollision(ball) {
            let bricksRemaining = false;
            
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    const brick = bricks[c][r];
                    if (brick.status > 0) {
                        bricksRemaining = true;
                        if (ball.x + ball.radius > brick.x && 
                            ball.x - ball.radius < brick.x + brickWidth &&
                            ball.y + ball.radius > brick.y && 
                            ball.y - ball.radius < brick.y + brickHeight) {
                            ball.dy = -ball.dy;
                            
                            // Check if this is a power-up brick
                            if (brick.status === BRICK_POWER_UP) {
                                // Give freeze ray power-up to player who hit the brick
                                const player = ball.lastHitBy;
                                const paddle = player === 1 ? paddle1 : paddle2;
                                paddle.hasFreezeRay = true;
                                
                                // Update power-up indicator
                                if (player === 1) {
                                    player1PowerUpIndicator.style.display = "block";
                                } else {
                                    player2PowerUpIndicator.style.display = "block";
                                }
                                
                                debug(`Player ${player} got freeze ray power-up!`);
                                soundFX.playPowerUp(); // Instead of soundManager.play('brickPowerUp')
                            }
                            // Check if this is a wide paddle power-up brick
                            else if (brick.status === BRICK_WIDE_PADDLE) {
                            // Create breaking effect
                            createBrickParticles(brick);
                            // Add 5 points to the player who last hit the ball
                            if (ball.lastHitBy === 1) {
                                paddle1.score += 5;
                                debug(`Player 1 scored 5 points for breaking a brick`);
                            } else {
                                paddle2.score += 5;
                                debug(`${gameMode === 1 ? 'AI' : 'Player 2'} scored 5 points for breaking a brick`);
                            }
                            soundFX.playBrickBreak();
                            debug(`Brick hit at position [${c},${r}] - points to player ${ball.lastHitBy}`);
                            return true;
                        }
                    }
                                // Give wide paddle power-up to player who hit the brick
                                const player = ball.lastHitBy;
                                const paddle = player === 1 ? paddle1 : paddle2;
                                
                                // Apply wide paddle power-up
                                if (!paddle.isWide) {
                                    paddle.originalWidth = paddle.width; // Store original width
                                }
                                
                                // Calculate new width (100% wider - double size)
                                paddle.width = paddle.originalWidth * 2.0;
                                
                                // Keep paddle centered at the same position
                                paddle.x -= (paddle.width - paddle.originalWidth) / 2;
                                
                                // Set power-up status
                                paddle.isWide = true;
                                paddle.widePaddleTimeRemaining = 10; // 10 seconds duration
                                
                                debug(`Player ${player} got wide paddle power-up for 10 seconds!`);
                                soundFX.playPowerUp(); // Instead of soundManager.play('powerUp')
                            }
                            // Check if this is a laser power-up brick
                            else if (brick.status === BRICK_LASER_POWER_UP) {
                }
            }
            
            // If no bricks remaining, reset them
            if (!bricksRemaining) {
                debug("All bricks destroyed - resetting");
                resetBricks();
                // Add bonus points for clearing all bricks
                paddle1.score += 20;
                paddle2.score += 20;
                soundFX.playLevelComplete();
            }
            
            return false;
        }

        // Add brick particle system for breaking animation
        const particles = [];
        
        class Particle {
            constructor(x, y, color) {
                                // Give laser power-up to player who hit the brick
                                const player = ball.lastHitBy;
                                const paddle = player === 1 ? paddle1 : paddle2;
                                paddle.hasLaser = true;
                                
                                // Update laser indicator
                                if (player === 1) {
                                    player1LaserIndicator.style.display = "block";
                                } else {
                                    player2LaserIndicator.style.display = "block";
                                }
                                
                                debug(`Player ${player} got laser power-up!`);
                                soundFX.playPowerUp(); // Instead of soundManager.play('laserPowerUp')
                            }
                            
                            brick.status = 0;
                this.x = x;
                this.y = y;
                this.color = color;
                this.size = 3;
                this.speedX = (Math.random() - 0.5) * 8;
                this.speedY = (Math.random() - 0.5) * 8;
                this.gravity = 0.1;
                this.life = 1.0; // Life value from 1 to 0
                this.decay = 0.02; // How fast particle fades
            }

            update() {
                this.x += this.speedX;
                this.y += this.speedY;
                this.speedY += this.gravity;
                this.life -= this.decay;
            }

            draw(ctx) {
                ctx.fillStyle = `rgba(${this.color}, ${this.life})`;
                ctx.fillRect(this.x, this.y, this.size, this.size);
            }
        }

        // Function to create brick breaking effect
        function createBrickParticles(brick) {
            // Convert brick color from HSL to RGB
            const temp = document.createElement('div');
            temp.style.color = brick.color;
            document.body.appendChild(temp);
            const rgb = window.getComputedStyle(temp).color;
            document.body.removeChild(temp);
            
            // Create particles
            for (let i = 0; i < 20; i++) {
                particles.push(new Particle(
                    brick.x + brickWidth / 2,
                    brick.y + brickHeight / 2,
                    rgb.slice(4, -1) // Remove 'rgb(' and ')'
                ));
            }
        }

        // Function to create ash particles (more dramatic than regular brick particles)
        function createAshParticles(object, count) {
            const x = object.x + brickWidth / 2;
            const y = object.y + brickHeight / 2;
            
            // Convert color to ash color (gray/black)
            const ashColors = ['rgba(30, 30, 30, 1)', 'rgba(50, 50, 50, 1)', 'rgba(70, 70, 70, 1)'];
            
            // Create particles
            for (let i = 0; i < count; i++) {
                const color = ashColors[Math.floor(Math.random() * ashColors.length)];
                const particle = new Particle(x, y, color);
                
                // Make ash particles live longer and move slower
                particle.decay = 0.01;
                particle.size = 4 + Math.random() * 3;
                particle.speedX *= 0.7;
                particle.speedY *= 0.7;
                
                particles.push(particle);
            }
        }

        // Controls
        const keys = {
            ArrowLeft: false,
            ArrowRight: false,
            a: false,
            d: false,
            Space: false, // For freeze ray
            s: false,     // For freeze ray
            Escape: false // For exiting to main menu
        };

        // Key down event
        document.addEventListener('keydown', (e) => {
            if (e.key in keys) {
                keys[e.key] = true;
                debug(`Key down: ${e.key}`);
            }
            // Additional handling for Space and S keys for freeze ray
            if (e.key === ' ' || e.code === 'Space') {
                keys.Space = true;
            }
            if (e.key === 's' || e.code === 'KeyS') {
                keys.s = true;
            }
            if (e.key === 'Escape') {
                keys.Escape = true;
                // Return to the start screen if game is running
                if (gameMode > 0) {
                    returnToStartScreen();
                }
            }
        });

        // Key up event
        document.addEventListener('keyup', (e) => {
            if (e.key in keys) {
                keys[e.key] = false;
                debug(`Key up: ${e.key}`);
            }
            // Additional handling for Space and S keys for freeze ray
            if (e.key === ' ' || e.code === 'Space') {
                keys.Space = false;
            }
            if (e.key === 's' || e.code === 'KeyS') {
                keys.s = false;
            }
            if (e.key === 'Escape') {
                keys.Escape = false;
            }
        });

        // Draw paddle
        function drawPaddle(paddle) {
            ctx.save();
            
            // If paddle is turned to ashes, draw ashes effect instead of normal paddle
            if (paddle.isAshes) {
                // Draw pile of ashes
                const paddleCenter = paddle.x + paddle.width / 2;
                const yPos = paddle === paddle1 ? paddle.y : paddle.y + paddle.height;
                
                // Draw ash pile
                ctx.beginPath();
                ctx.fillStyle = "#333333";
                
                if (paddle === paddle1) {
                    // Bottom paddle ash pile
                    const ashWidth = paddle.width * 0.8;
                    ctx.ellipse(paddleCenter, yPos, ashWidth/2, paddle.height/2, 0, 0, Math.PI * 2);
                } else {
                    // Top paddle ash pile
                    const ashWidth = paddle.width * 0.8;
                    ctx.ellipse(paddleCenter, yPos - paddle.height/2, ashWidth/2, paddle.height/2, 0, 0, Math.PI * 2);
                }
                
                ctx.fill();
                ctx.closePath();
                
                // Draw ash particles randomly floating up
                if (Math.random() < 0.3) { // Only spawn particles occasionally
                    const ashX = paddleCenter + (Math.random() - 0.5) * paddle.width * 0.6;
                    const ashY = paddle === paddle1 ? yPos - paddle.height/2 : yPos;
                    const particle = new Particle(ashX, ashY, "rgba(80, 80, 80, 0.7)");
                    
                    // Customize ash particle behavior
                    particle.size = 2 + Math.random() * 2;
                    particle.speedX = (Math.random() - 0.5) * 1;
                    particle.speedY = -1 - Math.random() * 1;
                    particle.gravity = 0.02;
                    
                    particles.push(particle);
                }
                
                // Display remaining time
                ctx.fillStyle = "#FFFFFF";
                ctx.font = "12px Arial";
                ctx.fillText(`${Math.ceil(paddle.ashesTimeRemaining)}s`, paddleCenter - 5, 
                            paddle === paddle1 ? yPos - 15 : yPos + 15);
                
                ctx.restore();
                return; // Skip drawing normal paddle
            }
            
            ctx.fillStyle = '#fff';
            
            ctx.beginPath();
            
            // Draw concave paddle using a path
            const curveHeight = paddle.height * paddle.curvature;
            const midX = paddle.x + paddle.width / 2;
            
            if (paddle === paddle1) {
                // Bottom paddle - concave on top side
                ctx.moveTo(paddle.x, paddle.y); // Top-left
                ctx.lineTo(paddle.x + paddle.width, paddle.y); // Top-right
                ctx.lineTo(paddle.x + paddle.width, paddle.y + paddle.height); // Bottom-right
                ctx.lineTo(paddle.x, paddle.y + paddle.height); // Bottom-left
                ctx.lineTo(paddle.x, paddle.y); // Back to top-left
                
                // Draw the concave curve on top
                ctx.moveTo(paddle.x, paddle.y);
                ctx.quadraticCurveTo(midX, paddle.y - curveHeight, paddle.x + paddle.width, paddle.y);
            } else {
                // Top paddle - concave on bottom side
                ctx.moveTo(paddle.x, paddle.y); // Top-left
                ctx.lineTo(paddle.x + paddle.width, paddle.y); // Top-right
                ctx.lineTo(paddle.x + paddle.width, paddle.y + paddle.height); // Bottom-right
                ctx.lineTo(paddle.x, paddle.y + paddle.height); // Bottom-left
                ctx.lineTo(paddle.x, paddle.y); // Back to top-left
                
                // Draw the concave curve on bottom
                ctx.moveTo(paddle.x, paddle.y + paddle.height);
                ctx.quadraticCurveTo(midX, paddle.y + paddle.height + curveHeight, paddle.x + paddle.width, paddle.y + paddle.height);
            }
            
            // Apply frozen effect if paddle is frozen
            if (paddle.isFrozen) {
                ctx.fillStyle = "#B0E0E6"; // Pale blue for frozen
                
                // Draw frozen timer
                ctx.fill();
                ctx.closePath();
                
                // Add frozen time indicator
                ctx.fillStyle = "#FFFFFF";
                ctx.font = "12px Arial";
                ctx.fillText(`${Math.ceil(paddle.frozenTimeRemaining)}s`, paddle.x + paddle.width / 2 - 5, 
                    paddle === paddle1 ? paddle.y - 10 : paddle.y + paddle.height + 20);
                
                // Add ice crystals
                for (let i = 0; i < 5; i++) {
                    ctx.beginPath();
                    const xPos = paddle.x + paddle.width * (i / 4);
                    const yPos = paddle === paddle1 ? paddle.y : paddle.y + paddle.height;
                    const direction = paddle === paddle1 ? -1 : 1;
                    
                    ctx.moveTo(xPos, yPos);
                    ctx.lineTo(xPos - 5, yPos + (8 * direction));
                    ctx.lineTo(xPos, yPos + (12 * direction));
                    ctx.lineTo(xPos + 5, yPos + (8 * direction));
                    ctx.closePath();
                    ctx.fillStyle = "#FFFFFF";
                    ctx.globalAlpha = 0.7;
                    ctx.fill();
                    ctx.globalAlpha = 1.0;
                }
            } else {
                // Normal paddle color or wide paddle color
                if (paddle.isWide) {
                    ctx.fillStyle = paddle === paddle1 ? "#AA55FF" : "#AA55FF"; // Purple tint for wide paddle
                    ctx.fill();
                    ctx.closePath();
                    
                    // Add wide paddle time indicator
                    ctx.fillStyle = "#FFFFFF";
                    ctx.font = "12px Arial";
                    ctx.fillText(`${Math.ceil(paddle.widePaddleTimeRemaining)}s`, paddle.x + paddle.width / 2 - 5, 
                        paddle === paddle1 ? paddle.y - 10 : paddle.y + paddle.height + 20);
                } else {
                    // Normal paddle color
                    ctx.fillStyle = paddle === paddle1 ? "#3498db" : "#e74c3c";
                    ctx.fill();
                    ctx.closePath();
                }
            }
            
            ctx.restore();
        }

        // Draw ball
        function drawBall() {
            balls.forEach(ball => {
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
                ctx.fillStyle = ball.owner === 1 ? '#ff4444' : '#44ff44'; // Different colors for each ball
                ctx.fill();
                ctx.closePath();
            });
        }

        // Draw score
        function drawScore() {
            ctx.fillStyle = '#fff';
            ctx.font = '24px Arial';
            
            // Determine player names based on game mode
            let player1Name = "Player 1";
            let player2Name = "Player 2";
            
            if (gameMode === 1) {
                player2Name = "AI";
            }
            
            ctx.fillText(`${player1Name}: ${paddle1.score}`, 20, canvas.height / 2 + 24);
            ctx.fillText(`${player2Name}: ${paddle2.score}`, 20, canvas.height / 2 - 24);
        }

        // Move paddles
        function movePaddles() {
            // Calculate movement for Player 1
            if (gameMode === 3) {
                // AI vs AI mode - AI for paddle1
                if (!paddle1.isFrozen) {
                    // Improved ball tracking logic - prioritize balls that are:
                    // 1. Owned by or last hit by this player
                    // 2. Moving toward this paddle
                    // 3. Closest to this paddle
                    
                    // Find balls moving toward this paddle (positive dy)
                    const approachingBalls = balls.filter(ball => ball.dy > 0);
                    
                    let ballToTrack;
                    
                    if (approachingBalls.length > 0) {
                        // First check if there's a ball owned by this player
                        ballToTrack = approachingBalls.find(ball => ball.lastHitBy === 1 || ball.owner === 1);
                        
                        // If no owned ball, pick the closest approaching ball
                        if (!ballToTrack) {
                            // Sort by closeness to this paddle (vertically)
                            approachingBalls.sort((a, b) => 
                                (paddle1.y - a.y) - (paddle1.y - b.y)
                            );
                            ballToTrack = approachingBalls[0];
                        }
                    } else {
                        // If no ball is approaching, track any ball
                        ballToTrack = balls.find(ball => ball.lastHitBy === 1 || ball.owner === 1) || balls[0];
                    }
                    
                    const targetX = ballToTrack.x - paddle1.width / 2;
                    const diff = targetX - paddle1.x;
                    
                    // Add some randomness to make AI less perfect
                    const randomness = (Math.random() - 0.5) * 15;
                    
                    // Smooth movement with error
                    if (Math.abs(diff) > 10) {
                        // Move faster when ball is further away
                        const speedFactor = Math.min(0.2, 0.1 + Math.abs(diff) / 1000);
                        paddle1.dx = diff * speedFactor + randomness * 0.05;
                        
                        // Limit AI paddle speed to match human player speed (5 pixels per frame)
                        const maxSpeed = 5;
                        if (paddle1.dx > maxSpeed) {
                            paddle1.dx = maxSpeed;
                        } else if (paddle1.dx < -maxSpeed) {
                            paddle1.dx = -maxSpeed;
                        }
                    } else {
                        paddle1.dx *= 0.8;
                    }
                    
                    // Apply movement
                    paddle1.x += paddle1.dx;
                } else {
                    // Frozen paddle can't move
                    paddle1.dx = 0;
                }
            } else {
                // Human player controls for paddle1
                if (!paddle1.isFrozen) {
                    if (keys.ArrowRight) {
                        paddle1.dx = 5;
                    } else if (keys.ArrowLeft) {
                        paddle1.dx = -5;
                    } else {
                        // Apply friction to gradually stop paddle
                        paddle1.dx *= 0.8;
                    }
                    
                    // Apply movement
                    paddle1.x += paddle1.dx;
                } else {
                    // Frozen paddle can't move
                    paddle1.dx = 0;
                }
            }
            
            // Player 2 controls
            if (gameMode === 2) {  // Only for 2-player mode (human control)
                if (!paddle2.isFrozen) {
                    if (keys.d) {
                        paddle2.dx = 5;
                    } else if (keys.a) {
                        paddle2.dx = -5;
                    } else {
                        // Apply friction to gradually stop paddle
                        paddle2.dx *= 0.8;
                    }
                    
                    // Apply movement
                    paddle2.x += paddle2.dx;
                } else {
                    // Frozen paddle can't move
                    paddle2.dx = 0;
                }
            } else {
                // If single player OR AI vs AI mode, implement AI for paddle2
                if (!paddle2.isFrozen) {
                    // Improved ball tracking logic - prioritize balls that are:
                    // 1. Owned by or last hit by this player
                    // 2. Moving toward this paddle
                    // 3. Closest to this paddle
                    
                    // Find balls moving toward this paddle (negative dy)
                    const approachingBalls = balls.filter(ball => ball.dy < 0);
                    
                    let ballToTrack;
                    
                    if (approachingBalls.length > 0) {
                        // First check if there's a ball owned by this player
                        ballToTrack = approachingBalls.find(ball => ball.lastHitBy === 2 || ball.owner === 2);
                        
                        // If no owned ball, pick the closest approaching ball
                        if (!ballToTrack) {
                            // Sort by closeness to this paddle (vertically)
                            approachingBalls.sort((a, b) => 
                                (a.y - paddle2.y) - (b.y - paddle2.y)
                            );
                            ballToTrack = approachingBalls[0];
                        }
                    } else {
                        // If no ball is approaching, track any ball
                        ballToTrack = balls.find(ball => ball.lastHitBy === 2 || ball.owner === 2) || balls[0];
                    }
                    
                    const targetX = ballToTrack.x - paddle2.width / 2;
                    const diff = targetX - paddle2.x;
                    
                    // Add some randomness to make AI less perfect
                    const randomness = (Math.random() - 0.5) * 15;
                    
                    // Smooth movement with error
                    if (Math.abs(diff) > 10) {
                        // Move faster when ball is further away
                        const speedFactor = Math.min(0.2, 0.1 + Math.abs(diff) / 1000);
                        paddle2.dx = diff * speedFactor + randomness * 0.05;
                        
                        // Limit AI paddle speed to match human player speed (5 pixels per frame)
                        const maxSpeed = 5;
                        if (paddle2.dx > maxSpeed) {
                            paddle2.dx = maxSpeed;
                        } else if (paddle2.dx < -maxSpeed) {
                            paddle2.dx = -maxSpeed;
                        }
                    } else {
                        paddle2.dx *= 0.8;
                    }
                    
                    // Apply movement
                    paddle2.x += paddle2.dx;
                } else {
                    // Frozen paddle can't move
                    paddle2.dx = 0;
                }
            }
            
            // Handle shooting freeze rays for Player 1
            if (paddle1.hasFreezeRay) {
                if (gameMode !== 3 && keys.Space) {
                    // Human player 1 shoots freeze ray
                    shootFreezeRay(1);
                    paddle1.hasFreezeRay = false;
                    player1PowerUpIndicator.style.display = "none";
                    soundFX.playFreezeRay();
                    keys.Space = false; // Prevent holding the key
                } else if (gameMode === 3) {
                    // AI should shoot more strategically
                            // Create breaking effect
                            createBrickParticles(brick);
                            // Add 5 points to the player who last hit the ball
                            if (ball.lastHitBy === 1) {
                                paddle1.score += 5;
                                debug(`Player 1 scored 5 points for breaking a brick`);
                            } else {
                                paddle2.score += 5;
                                debug(`${gameMode === 1 ? 'AI' : 'Player 2'} scored 5 points for breaking a brick`);
                            }
                            soundFX.playBrickBreak(); // Instead of soundManager.play('brickBreak')
                            debug(`Brick hit at position [${c},${r}] - points to player ${ball.lastHitBy}`);
                    // Check if the opponent paddle is in a good alignment for a hit
                    const paddleAlignmentThreshold = 20; // Acceptable offset for aiming
                    const isAligned = Math.abs(paddle1.x + paddle1.width / 2 - paddle2.x - paddle2.width / 2) < paddleAlignmentThreshold;
                    
                    // Higher chance to shoot when aligned, small random chance otherwise
                    if ((isAligned && Math.random() < 0.1) || Math.random() < 0.005) {
                        // Position paddle to better aim before shooting
                        const targetX = paddle2.x + paddle2.width / 2 - paddle1.width / 2;
                        // If we're close enough to the target position, shoot
                        if (Math.abs(paddle1.x - targetX) < 10 || isAligned) {
                            shootFreezeRay(1);
                            paddle1.hasFreezeRay = false;
                            player1PowerUpIndicator.style.display = "none";
                            soundFX.playFreezeRay();
                            debug("AI 1 shoots freeze ray at AI 2");
                        }
                    }
                }
            }
            
            // Handle shooting freeze rays for Player 2
                            return true;
                        }
                    }
                }
            }
            
            // If no bricks remaining, reset them
            if (!bricksRemaining) {
                debug("All bricks destroyed - resetting");
                resetBricks();
                // Add bonus points for clearing all bricks
                paddle1.score += 20;
                paddle2.score += 20;
                soundFX.playLevelComplete(); // Instead of soundManager.play('levelComplete')
            }
            
            return false;
        }

        // Add brick particle system for breaking animation
            if (paddle2.hasFreezeRay) {
                if (gameMode === 2 && keys.s) {
                    // Human player 2 shoots freeze ray
                    shootFreezeRay(2);
                    paddle2.hasFreezeRay = false;
                    player2PowerUpIndicator.style.display = "none";
                    soundFX.playFreezeRay();
                    keys.s = false; // Prevent holding the key
                } else if (gameMode !== 2) {
                    // AI should shoot more strategically
                    // Check if the opponent paddle is in a good alignment for a hit
        const particles = [];
        
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.size = 3;
                this.speedX = (Math.random() - 0.5) * 8;
                this.speedY = (Math.random() - 0.5) * 8;
                this.gravity = 0.1;
                this.life = 1.0; // Life value from 1 to 0
                this.decay = 0.02; // How fast particle fades
            }

            update() {
                this.x += this.speedX;
                this.y += this.speedY;
                this.speedY += this.gravity;
                this.life -= this.decay;
            }

            draw(ctx) {
                ctx.fillStyle = `rgba(${this.color}, ${this.life})`;
                ctx.fillRect(this.x, this.y, this.size, this.size);
            }
        }

        // Function to create brick breaking effect
        function createBrickParticles(brick) {
            // Convert brick color from HSL to RGB
            const temp = document.createElement('div');
            temp.style.color = brick.color;
            document.body.appendChild(temp);
            const rgb = window.getComputedStyle(temp).color;
            document.body.removeChild(temp);
            
            // Create particles
            for (let i = 0; i < 20; i++) {
                particles.push(new Particle(
                    brick.x + brickWidth / 2,
                    brick.y + brickHeight / 2,
                    rgb.slice(4, -1) // Remove 'rgb(' and ')'
                ));
            }
        }

        // Function to create ash particles (more dramatic than regular brick particles)
        function createAshParticles(object, count) {
            const x = object.x + brickWidth / 2;
            const y = object.y + brickHeight / 2;
            
            // Convert color to ash color (gray/black)
            const ashColors = ['rgba(30, 30, 30, 1)', 'rgba(50, 50, 50, 1)', 'rgba(70, 70, 70, 1)'];
            
            // Create particles
            for (let i = 0; i < count; i++) {
                const color = ashColors[Math.floor(Math.random() * ashColors.length)];
                const particle = new Particle(x, y, color);
                
                // Make ash particles live longer and move slower
                particle.decay = 0.01;
                particle.size = 4 + Math.random() * 3;
                particle.speedX *= 0.7;
                particle.speedY *= 0.7;
                
                particles.push(particle);
            }
        }

        // Controls
        const keys = {
            ArrowLeft: false,
            ArrowRight: false,
            a: false,
            d: false,
            Space: false, // For freeze ray
            s: false,     // For freeze ray
            Escape: false // For exiting to main menu
        };

        // Key down event
        document.addEventListener('keydown', (e) => {
            if (e.key in keys) {
                keys[e.key] = true;
                debug(`Key down: ${e.key}`);
            }
            // Additional handling for Space and S keys for freeze ray
            if (e.key === ' ' || e.code === 'Space') {
                keys.Space = true;
            }
            if (e.key === 's' || e.code === 'KeyS') {
                keys.s = true;
            }
            if (e.key === 'Escape') {
                keys.Escape = true;
                // Return to the start screen if game is running
                if (gameMode > 0) {
                    returnToStartScreen();
                }
            }
        });

        // Key up event
        document.addEventListener('keyup', (e) => {
            if (e.key in keys) {
                keys[e.key] = false;
                debug(`Key up: ${e.key}`);
            }
            // Additional handling for Space and S keys for freeze ray
            if (e.key === ' ' || e.code === 'Space') {
                keys.Space = false;
            }
            if (e.key === 's' || e.code === 'KeyS') {
                keys.s = false;
            }
            if (e.key === 'Escape') {
                keys.Escape = false;
            }
        });

        // Draw paddle
        function drawPaddle(paddle) {
            ctx.save();
            
            // If paddle is turned to ashes, draw ashes effect instead of normal paddle
            if (paddle.isAshes) {
                // Draw pile of ashes
                const paddleCenter = paddle.x + paddle.width / 2;
                const yPos = paddle === paddle1 ? paddle.y : paddle.y + paddle.height;
                
                // Draw ash pile
                ctx.beginPath();
                ctx.fillStyle = "#333333";
                
                if (paddle === paddle1) {
                    // Bottom paddle ash pile
                    const ashWidth = paddle.width * 0.8;
                    ctx.ellipse(paddleCenter, yPos, ashWidth/2, paddle.height/2, 0, 0, Math.PI * 2);
                } else {
                    // Top paddle ash pile
                    const ashWidth = paddle.width * 0.8;
                    ctx.ellipse(paddleCenter, yPos - paddle.height/2, ashWidth/2, paddle.height/2, 0, 0, Math.PI * 2);
                }
                
                ctx.fill();
                ctx.closePath();
                
                // Draw ash particles randomly floating up
                if (Math.random() < 0.3) { // Only spawn particles occasionally
                    const ashX = paddleCenter + (Math.random() - 0.5) * paddle.width * 0.6;
                    const ashY = paddle === paddle1 ? yPos - paddle.height/2 : yPos;
                    const particle = new Particle(ashX, ashY, "rgba(80, 80, 80, 0.7)");
                    
                    // Customize ash particle behavior
                    particle.size = 2 + Math.random() * 2;
                    particle.speedX = (Math.random() - 0.5) * 1;
                    particle.speedY = -1 - Math.random() * 1;
                    particle.gravity = 0.02;
                    
                    particles.push(particle);
                }
                
                // Display remaining time
                ctx.fillStyle = "#FFFFFF";
                ctx.font = "12px Arial";
                ctx.fillText(`${Math.ceil(paddle.ashesTimeRemaining)}s`, paddleCenter - 5, 
                            paddle === paddle1 ? yPos - 15 : yPos + 15);
                
                ctx.restore();
                return; // Skip drawing normal paddle
            }
            
            ctx.fillStyle = '#fff';
            
            ctx.beginPath();
            
            // Draw concave paddle using a path
            const curveHeight = paddle.height * paddle.curvature;
            const midX = paddle.x + paddle.width / 2;
            
            if (paddle === paddle1) {
                // Bottom paddle - concave on top side
                ctx.moveTo(paddle.x, paddle.y); // Top-left
                ctx.lineTo(paddle.x + paddle.width, paddle.y); // Top-right
                ctx.lineTo(paddle.x + paddle.width, paddle.y + paddle.height); // Bottom-right
                ctx.lineTo(paddle.x, paddle.y + paddle.height); // Bottom-left
                ctx.lineTo(paddle.x, paddle.y); // Back to top-left
                
                // Draw the concave curve on top
                ctx.moveTo(paddle.x, paddle.y);
                ctx.quadraticCurveTo(midX, paddle.y - curveHeight, paddle.x + paddle.width, paddle.y);
            } else {
                // Top paddle - concave on bottom side
                ctx.moveTo(paddle.x, paddle.y); // Top-left
                ctx.lineTo(paddle.x + paddle.width, paddle.y); // Top-right
                ctx.lineTo(paddle.x + paddle.width, paddle.y + paddle.height); // Bottom-right
                ctx.lineTo(paddle.x, paddle.y + paddle.height); // Bottom-left
                ctx.lineTo(paddle.x, paddle.y); // Back to top-left
                
                // Draw the concave curve on bottom
                ctx.moveTo(paddle.x, paddle.y + paddle.height);
                ctx.quadraticCurveTo(midX, paddle.y + paddle.height + curveHeight, paddle.x + paddle.width, paddle.y + paddle.height);
            }
            
            // Apply frozen effect if paddle is frozen
            if (paddle.isFrozen) {
                ctx.fillStyle = "#B0E0E6"; // Pale blue for frozen
                
                // Draw frozen timer
                ctx.fill();
                ctx.closePath();
                
                // Add frozen time indicator
                ctx.fillStyle = "#FFFFFF";
                ctx.font = "12px Arial";
                ctx.fillText(`${Math.ceil(paddle.frozenTimeRemaining)}s`, paddle.x + paddle.width / 2 - 5, 
                    paddle === paddle1 ? paddle.y - 10 : paddle.y + paddle.height + 20);
                
                // Add ice crystals
                for (let i = 0; i < 5; i++) {
                    ctx.beginPath();
                    const xPos = paddle.x + paddle.width * (i / 4);
                    const yPos = paddle === paddle1 ? paddle.y : paddle.y + paddle.height;
                    const direction = paddle === paddle1 ? -1 : 1;
                    
                    ctx.moveTo(xPos, yPos);
                    ctx.lineTo(xPos - 5, yPos + (8 * direction));
                    ctx.lineTo(xPos, yPos + (12 * direction));
                    ctx.lineTo(xPos + 5, yPos + (8 * direction));
                    ctx.closePath();
                    ctx.fillStyle = "#FFFFFF";
                    ctx.globalAlpha = 0.7;
                    ctx.fill();
                    ctx.globalAlpha = 1.0;
                }
            } else {
                // Normal paddle color or wide paddle color
                if (paddle.isWide) {
                    ctx.fillStyle = paddle === paddle1 ? "#AA55FF" : "#AA55FF"; // Purple tint for wide paddle
                    ctx.fill();
                    ctx.closePath();
                    
                    // Add wide paddle time indicator
                    ctx.fillStyle = "#FFFFFF";
                    ctx.font = "12px Arial";
                    ctx.fillText(`${Math.ceil(paddle.widePaddleTimeRemaining)}s`, paddle.x + paddle.width / 2 - 5, 
                        paddle === paddle1 ? paddle.y - 10 : paddle.y + paddle.height + 20);
                } else {
                    // Normal paddle color
                    ctx.fillStyle = paddle === paddle1 ? "#3498db" : "#e74c3c";
                    ctx.fill();
                    ctx.closePath();
                }
            }
            
            ctx.restore();
        }

        // Draw ball
        function drawBall() {
            balls.forEach(ball => {
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
                ctx.fillStyle = ball.owner === 1 ? '#ff4444' : '#44ff44'; // Different colors for each ball
                ctx.fill();
                ctx.closePath();
            });
        }

        // Draw score
        function drawScore() {
            ctx.fillStyle = '#fff';
            ctx.font = '24px Arial';
            
            // Determine player names based on game mode
            let player1Name = "Player 1";
            let player2Name = "Player 2";
            
            if (gameMode === 1) {
                player2Name = "AI";
            }
            
            ctx.fillText(`${player1Name}: ${paddle1.score}`, 20, canvas.height / 2 + 24);
            ctx.fillText(`${player2Name}: ${paddle2.score}`, 20, canvas.height / 2 - 24);
        }

        // Move paddles
        function movePaddles() {
            // Calculate movement for Player 1
            if (gameMode === 3) {
                // AI vs AI mode - AI for paddle1
                if (!paddle1.isFrozen) {
                    // Improved ball tracking logic - prioritize balls that are:
                    // 1. Owned by or last hit by this player
                    // 2. Moving toward this paddle
                    // 3. Closest to this paddle
                    
                    // Find balls moving toward this paddle (positive dy)
                    const approachingBalls = balls.filter(ball => ball.dy > 0);
                    
                    let ballToTrack;
                    
                    if (approachingBalls.length > 0) {
                        // First check if there's a ball owned by this player
                        ballToTrack = approachingBalls.find(ball => ball.lastHitBy === 1 || ball.owner === 1);
                        
                        // If no owned ball, pick the closest approaching ball
                        if (!ballToTrack) {
                            // Sort by closeness to this paddle (vertically)
                            approachingBalls.sort((a, b) => 
                                (paddle1.y - a.y) - (paddle1.y - b.y)
                            );
                            ballToTrack = approachingBalls[0];
                        }
                    } else {
                        // If no ball is approaching, track any ball
                        ballToTrack = balls.find(ball => ball.lastHitBy === 1 || ball.owner === 1) || balls[0];
                    }
                    
                    const targetX = ballToTrack.x - paddle1.width / 2;
                    const diff = targetX - paddle1.x;
                    
                    // Add some randomness to make AI less perfect
                    const randomness = (Math.random() - 0.5) * 15;
                    
                    // Smooth movement with error
                    if (Math.abs(diff) > 10) {
                        // Move faster when ball is further away
                        const speedFactor = Math.min(0.2, 0.1 + Math.abs(diff) / 1000);
                        paddle1.dx = diff * speedFactor + randomness * 0.05;
                        
                        // Limit AI paddle speed to match human player speed (5 pixels per frame)
                        const maxSpeed = 5;
                        if (paddle1.dx > maxSpeed) {
                            paddle1.dx = maxSpeed;
                        } else if (paddle1.dx < -maxSpeed) {
                            paddle1.dx = -maxSpeed;
                        }
                    } else {
                        paddle1.dx *= 0.8;
                    }
                    
                    // Apply movement
                    paddle1.x += paddle1.dx;
                } else {
                    // Frozen paddle can't move
                    paddle1.dx = 0;
                }
            } else {
                // Human player controls for paddle1
                if (!paddle1.isFrozen) {
                    if (keys.ArrowRight) {
                        paddle1.dx = 5;
                    } else if (keys.ArrowLeft) {
                        paddle1.dx = -5;
                    } else {
                        // Apply friction to gradually stop paddle
                        paddle1.dx *= 0.8;
                    }
                    
                    // Apply movement
                    paddle1.x += paddle1.dx;
                } else {
                    // Frozen paddle can't move
                    paddle1.dx = 0;
                }
            }
            
            // Player 2 controls
            if (gameMode === 2) {  // Only for 2-player mode (human control)
                if (!paddle2.isFrozen) {
                    if (keys.d) {
                        paddle2.dx = 5;
                    } else if (keys.a) {
                        paddle2.dx = -5;
                    } else {
                        // Apply friction to gradually stop paddle
                        paddle2.dx *= 0.8;
                    }
                    
                    // Apply movement
                    paddle2.x += paddle2.dx;
                } else {
                    // Frozen paddle can't move
                    paddle2.dx = 0;
                }
            } else {
                // If single player OR AI vs AI mode, implement AI for paddle2
                if (!paddle2.isFrozen) {
                    // Improved ball tracking logic - prioritize balls that are:
                    // 1. Owned by or last hit by this player
                    // 2. Moving toward this paddle
                    // 3. Closest to this paddle
                    
                    // Find balls moving toward this paddle (negative dy)
                    const approachingBalls = balls.filter(ball => ball.dy < 0);
                    
                    let ballToTrack;
                    
                    if (approachingBalls.length > 0) {
                        // First check if there's a ball owned by this player
                        ballToTrack = approachingBalls.find(ball => ball.lastHitBy === 2 || ball.owner === 2);
                        
                        // If no owned ball, pick the closest approaching ball
                        if (!ballToTrack) {
                            // Sort by closeness to this paddle (vertically)
                            approachingBalls.sort((a, b) => 
                                (a.y - paddle2.y) - (b.y - paddle2.y)
                            );
                            ballToTrack = approachingBalls[0];
                        }
                    } else {
                        // If no ball is approaching, track any ball
                        ballToTrack = balls.find(ball => ball.lastHitBy === 2 || ball.owner === 2) || balls[0];
                    }
                    
                    const targetX = ballToTrack.x - paddle2.width / 2;
                    const diff = targetX - paddle2.x;
                    
                    // Add some randomness to make AI less perfect
                    const randomness = (Math.random() - 0.5) * 15;
                    
                    // Smooth movement with error
                    if (Math.abs(diff) > 10) {
                        // Move faster when ball is further away
                        const speedFactor = Math.min(0.2, 0.1 + Math.abs(diff) / 1000);
                        paddle2.dx = diff * speedFactor + randomness * 0.05;
                        
                        // Limit AI paddle speed to match human player speed (5 pixels per frame)
                        const maxSpeed = 5;
                        if (paddle2.dx > maxSpeed) {
                            paddle2.dx = maxSpeed;
                        } else if (paddle2.dx < -maxSpeed) {
                            paddle2.dx = -maxSpeed;
                        }
                    } else {
                        paddle2.dx *= 0.8;
                    }
                    
                    // Apply movement
                    paddle2.x += paddle2.dx;
                } else {
                    // Frozen paddle can't move
                    paddle2.dx = 0;
                }
            }
            
            // Handle shooting freeze rays for Player 1
            if (paddle1.hasFreezeRay) {
                if (gameMode !== 3 && keys.Space) {
                    // Human player 1 shoots freeze ray
                    shootFreezeRay(1);
                    paddle1.hasFreezeRay = false;
                    player1PowerUpIndicator.style.display = "none";
                    soundFX.playFreezeRay();
                    keys.Space = false; // Prevent holding the key
                } else if (gameMode === 3) {
                    // AI should shoot more strategically
                            // Create breaking effect
                            createBrickParticles(brick);
                            // Add 5 points to the player who last hit the ball
                            if (ball.lastHitBy === 1) {
                                paddle1.score += 5;
                                debug(`Player 1 scored 5 points for breaking a brick`);
                            } else {
                                paddle2.score += 5;
                                debug(`${gameMode === 1 ? 'AI' : 'Player 2'} scored 5 points for breaking a brick`);
                            }
                            soundFX.playBrickBreak(); // Instead of soundManager.play('brickBreak')
                            debug(`Brick hit at position [${c},${r}] - points to player ${ball.lastHitBy}`);
                    // Check if the opponent paddle is in a good alignment for a hit
                    const paddleAlignmentThreshold = 20; // Acceptable offset for aiming
                    const isAligned = Math.abs(paddle1.x + paddle1.width / 2 - paddle2.x - paddle2.width / 2) < paddleAlignmentThreshold;
                    
                    // Higher chance to shoot when aligned, small random chance otherwise
                    if ((isAligned && Math.random() < 0.1) || Math.random() < 0.005) {
                        // Position paddle to better aim before shooting
                        const targetX = paddle2.x + paddle2.width / 2 - paddle1.width / 2;
                        // If we're close enough to the target position, shoot
                        if (Math.abs(paddle1.x - targetX) < 10 || isAligned) {
                            shootFreezeRay(1);
                            paddle1.hasFreezeRay = false;
                            player1PowerUpIndicator.style.display = "none";
                            soundFX.playFreezeRay();
                            debug("AI 1 shoots freeze ray at AI 2");
                        }
                    }
                }
            }
            
            // Handle shooting freeze rays for Player 2
                            return true;
                        }
                    }
                }
            }
            
            // If no bricks remaining, reset them
            if (!bricksRemaining) {
                debug("All bricks destroyed - resetting");
                resetBricks();
                // Add bonus points for clearing all bricks
                paddle1.score += 20;
                paddle2.score += 20;
                soundFX.playLevelComplete(); // Instead of soundManager.play('levelComplete')
            }
            
            return false;
        }

        // Add brick particle system for breaking animation
            if (paddle2.hasFreezeRay) {
                if (gameMode === 2 && keys.s) {
                    // Human player 2 shoots freeze ray
                    shootFreezeRay(2);
                    paddle2.hasFreezeRay = false;
                    player2PowerUpIndicator.style.display = "none";
                    soundFX.playFreezeRay();
                    keys.s = false; // Prevent holding the key
                } else if (gameMode !== 2) {
                    // AI should shoot more strategically
                    // Check if the opponent paddle is in a good alignment for a hit
        const particles = [];
        
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.size = 3;
                this.speedX = (Math.random() - 0.5) * 8;
                this.speedY = (Math.random() - 0.5) * 8;
                this.gravity = 0.1;
                this.life = 1.0; // Life value from 1 to 0
                this.decay = 0.02; // How fast particle fades
            }

            update() {
                this.x += this.speedX;
                this.y += this.speedY;
                this.speedY += this.gravity;
                this.life -= this.decay;
            }

            draw(ctx) {
                ctx.fillStyle = `rgba(${this.color}, ${this.life})`;
                ctx.fillRect(this.x, this.y, this.size, this.size);
            }
        }

        // Function to create brick breaking effect
        function createBrickParticles(brick) {
            // Convert brick color from HSL to RGB
            const temp = document.createElement('div');
            temp.style.color = brick.color;
            document.body.appendChild(temp);
            const rgb = window.getComputedStyle(temp).color;
            document.body.removeChild(temp);
            
            // Create particles
            for (let i = 0; i < 20; i++) {
                particles.push(new Particle(
                    brick.x + brickWidth / 2,
                    brick.y + brickHeight / 2,
                    rgb.slice(4, -1) // Remove 'rgb(' and ')'
                ));
            }
        }

        // Function to create ash particles (more dramatic than regular brick particles)
        function createAshParticles(object, count) {
            const x = object.x + brickWidth / 2;
            const y = object.y + brickHeight / 2;
            
            // Convert color to ash color (gray/black)
            const ashColors = ['rgba(30, 30, 30, 1)', 'rgba(50, 50, 50, 1)', 'rgba(70, 70, 70, 1)'];
            
            // Create particles
            for (let i = 0; i < count; i++) {
                const color = ashColors[Math.floor(Math.random() * ashColors.length)];
                const particle = new Particle(x, y, color);
                
                // Make ash particles live longer and move slower
                particle.decay = 0.01;
                particle.size = 4 + Math.random() * 3;
                particle.speedX *= 0.7;
                particle.speedY *= 0.7;
                
                particles.push(particle);
            }
        }

        // Controls
        const keys = {
            ArrowLeft: false,
            ArrowRight: false,
            a: false,
            d: false,
            Space: false, // For freeze ray
            s: false,     // For freeze ray
            Escape: false // For exiting to main menu
        };

        // Key down event
        document.addEventListener('keydown', (e) => {
            if (e.key in keys) {
                keys[e.key] = true;
                debug(`Key down: ${e.key}`);
            }
            // Additional handling for Space and S keys for freeze ray
            if (e.key === ' ' || e.code === 'Space') {
                keys.Space = true;
            }
            if (e.key === 's' || e.code === 'KeyS') {
                keys.s = true;
            }
            if (e.key === 'Escape') {
                keys.Escape = true;
                // Return to the start screen if game is running
                if (gameMode > 0) {
                    returnToStartScreen();
                }
            }
        });

        // Key up event
        document.addEventListener('keyup', (e) => {
            if (e.key in keys) {
                keys[e.key] = false;
                debug(`Key up: ${e.key}`);
            }
            // Additional handling for Space and S keys for freeze ray
            if (e.key === ' ' || e.code === 'Space') {
                keys.Space = false;
            }
            if (e.key === 's' || e.code === 'KeyS') {
                keys.s = false;
            }
            if (e.key === 'Escape') {
                keys.Escape = false;
            }
        });

        // Draw paddle
        function drawPaddle(paddle) {
            ctx.save();
            
            // If paddle is turned to ashes, draw ashes effect instead of normal paddle
            if (paddle.isAshes) {
                // Draw pile of ashes
                const paddleCenter = paddle.x + paddle.width / 2;
                const yPos = paddle === paddle1 ? paddle.y : paddle.y + paddle.height;
                
                // Draw ash pile
                ctx.beginPath();
                ctx.fillStyle = "#333333";
                
                if (paddle === paddle1) {
                    // Bottom paddle ash pile
                    const ashWidth = paddle.width * 0.8;
                    ctx.ellipse(paddleCenter, yPos, ashWidth/2, paddle.height/2, 0, 0, Math.PI * 2);
                } else {
                    // Top paddle ash pile
                    const ashWidth = paddle.width * 0.8;
                    ctx.ellipse(paddleCenter, yPos - paddle.height/2, ashWidth/2, paddle.height/2, 0, 0, Math.PI * 2);
                }
                
                ctx.fill();
                ctx.closePath();
                
                // Draw ash particles randomly floating up
                if (Math.random() < 0.3) { // Only spawn particles occasionally
                    const ashX = paddleCenter + (Math.random() - 0.5) * paddle.width * 0.6;
                    const ashY = paddle === paddle1 ? yPos - paddle.height/2 : yPos;
                    const particle = new Particle(ashX, ashY, "rgba(80, 80, 80, 0.7)");
                    
                    // Customize ash particle behavior
                    particle.size = 2 + Math.random() * 2;
                    particle.speedX = (Math.random() - 0.5) * 1;
                    particle.speedY = -1 - Math.random() * 1;
                    particle.gravity = 0.02;
                    
                    particles.push(particle);
                }
                
                // Display remaining time
                ctx.fillStyle = "#FFFFFF";
                ctx.font = "12px Arial";
                ctx.fillText(`${Math.ceil(paddle.ashesTimeRemaining)}s`, paddleCenter - 5, 
                            paddle === paddle1 ? yPos - 15 : yPos + 15);
                
                ctx.restore();
                return; // Skip drawing normal paddle
            }
            
            ctx.fillStyle = '#fff';
            
            ctx.beginPath();
            
            // Draw concave paddle using a path
            const curveHeight = paddle.height * paddle.curvature;
            const midX = paddle.x + paddle.width / 2;
            
            if (paddle === paddle1) {
                // Bottom paddle - concave on top side
                ctx.moveTo(paddle.x, paddle.y); // Top-left
                ctx.lineTo(paddle.x + paddle.width, paddle.y); // Top-right
                ctx.lineTo(paddle.x + paddle.width, paddle.y + paddle.height); // Bottom-right
                ctx.lineTo(paddle.x, paddle.y + paddle.height); // Bottom-left
                ctx.lineTo(paddle.x, paddle.y); // Back to top-left
                
                // Draw the concave curve on top
                ctx.moveTo(paddle.x, paddle.y);
                ctx.quadraticCurveTo(midX, paddle.y - curveHeight, paddle.x + paddle.width, paddle.y);
            } else {
                // Top paddle - concave on bottom side
                ctx.moveTo(paddle.x, paddle.y); // Top-left
                ctx.lineTo(paddle.x + paddle.width, paddle.y); // Top-right
                ctx.lineTo(paddle.x + paddle.width, paddle.y + paddle.height); // Bottom-right
                ctx.lineTo(paddle.x, paddle.y + paddle.height); // Bottom-left
                ctx.lineTo(paddle.x, paddle.y); // Back to top-left
                
                // Draw the concave curve on bottom
                ctx.moveTo(paddle.x, paddle.y + paddle.height);
                ctx.quadraticCurveTo(midX, paddle.y + paddle.height + curveHeight, paddle.x + paddle.width, paddle.y + paddle.height);
            }
            
            // Apply frozen effect if paddle is frozen
            if (paddle.isFrozen) {
                ctx.fillStyle = "#B0E0E6"; // Pale blue for frozen
                
                // Draw frozen timer
                ctx.fill();
                ctx.closePath();
                
                // Add frozen time indicator
                ctx.fillStyle = "#FFFFFF";
                ctx.font = "12px Arial";
                ctx.fillText(`${Math.ceil(paddle.frozenTimeRemaining)}s`, paddle.x + paddle.width / 2 - 5, 
                    paddle === paddle1 ? paddle.y - 10 : paddle.y + paddle.height + 20);
                
                // Add ice crystals
                for (let i = 0; i < 5; i++) {
                    ctx.beginPath();
                    const xPos = paddle.x + paddle.width * (i / 4);
                    const yPos = paddle === paddle1 ? paddle.y : paddle.y + paddle.height;
                    const direction = paddle === paddle1 ? -1 : 1;
                    
                    ctx.moveTo(xPos, yPos);
                    ctx.lineTo(xPos - 5, yPos + (8 * direction));
                    ctx.lineTo(xPos, yPos + (12 * direction));
                    ctx.lineTo(xPos + 5, yPos + (8 * direction));
                    ctx.closePath();
                    ctx.fillStyle = "#FFFFFF";
                    ctx.globalAlpha = 0.7;
                    ctx.fill();
                    ctx.globalAlpha = 1.0;
                }
            } else {
                // Normal paddle color or wide paddle color
                if (paddle.isWide) {
                    ctx.fillStyle = paddle === paddle1 ? "#AA55FF" : "#AA55FF"; // Purple tint for wide paddle
                    ctx.fill();
                    ctx.closePath();
                    
                    // Add wide paddle time indicator
                    ctx.fillStyle = "#FFFFFF";
                    ctx.font = "12px Arial";
                    ctx.fillText(`${Math.ceil(paddle.widePaddleTimeRemaining)}s`, paddle.x + paddle.width / 2 - 5, 
                        paddle === paddle1 ? paddle.y - 10 : paddle.y + paddle.height + 20);
                } else {
                    // Normal paddle color
                    ctx.fillStyle = paddle === paddle1 ? "#3498db" : "#e74c3c";
                    ctx.fill();
                    ctx.closePath();
                }
            }
            
            ctx.restore();
        }

        // Draw ball
        function drawBall() {
            balls.forEach(ball => {
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
                ctx.fillStyle = ball.owner === 1 ? '#ff4444' : '#44ff44'; // Different colors for each ball
                ctx.fill();
                ctx.closePath();
            });
        }

        // Draw score
        function drawScore() {
            ctx.fillStyle = '#fff';
            ctx.font = '24px Arial';
            
            // Determine player names based on game mode
            let player1Name = "Player 1";
            let player2Name = "Player 2";
            
            if (gameMode === 1) {
                player2Name = "AI";
            }
            
            ctx.fillText(`${player1Name}: ${paddle1.score}`, 20, canvas.height / 2 + 24);
            ctx.fillText(`${player2Name}: ${paddle2.score}`, 20, canvas.height / 2 - 24);
        }

        // Move paddles
        function movePaddles() {
            // Calculate movement for Player 1
            if (gameMode === 3) {
                // AI vs AI mode - AI for paddle1
                if (!paddle1.isFrozen) {
                    // Improved ball tracking logic - prioritize balls that are:
                    // 1. Owned by or last hit by this player
                    // 2. Moving toward this paddle
                    // 3. Closest to this paddle
                    
                    // Find balls moving toward this paddle (positive dy)
                    const approachingBalls = balls.filter(ball => ball.dy > 0);
                    
                    let ballToTrack;
                    
                    if (approachingBalls.length > 0) {
                        // First check if there's a ball owned by this player
                        ballToTrack = approachingBalls.find(ball => ball.lastHitBy === 1 || ball.owner === 1);
                        
                        // If no owned ball, pick the closest approaching ball
                        if (!ballToTrack) {
                            // Sort by closeness to this paddle (vertically)
                            approachingBalls.sort((a, b) => 
                                (paddle1.y - a.y) - (paddle1.y - b.y)
                            );
                            ballToTrack = approachingBalls[0];
                        }
                    } else {
                        // If no ball is approaching, track any ball
                        ballToTrack = balls.find(ball => ball.lastHitBy === 1 || ball.owner === 1) || balls[0];
                    }
                    
                    const targetX = ballToTrack.x - paddle1.width / 2;
                    const diff = targetX - paddle1.x;
                    
                    // Add some randomness to make AI less perfect
                    const randomness = (Math.random() - 0.5) * 15;
                    
                    // Smooth movement with error
                    if (Math.abs(diff) > 10) {
                        // Move faster when ball is further away
                        const speedFactor = Math.min(0.2, 0.1 + Math.abs(diff) / 1000);
                        paddle1.dx = diff * speedFactor + randomness * 0.05;
                        
                        // Limit AI paddle speed to match human player speed (5 pixels per frame)
                        const maxSpeed = 5;
                        if (paddle1.dx > maxSpeed) {
                            paddle1.dx = maxSpeed;
                        } else if (paddle1.dx < -maxSpeed) {
                            paddle1.dx = -maxSpeed;
                        }
                    } else {
                        paddle1.dx *= 0.8;
                    }
                    
                    // Apply movement
                    paddle1.x += paddle1.dx;
                } else {
                    // Frozen paddle can't move
                    paddle1.dx = 0;
                }
            } else {
                // Human player controls for paddle1
                if (!paddle1.isFrozen) {
                    if (keys.ArrowRight) {
                        paddle1.dx = 5;
                    } else if (keys.ArrowLeft) {
                        paddle1.dx = -5;
                    } else {
                        // Apply friction to gradually stop paddle
                        paddle1.dx *= 0.8;
                    }
                    
                    // Apply movement
                    paddle1.x += paddle1.dx;
                } else {
                    // Frozen paddle can't move
                    paddle1.dx = 0;
                }
            }
            
            // Player 2 controls
            if (gameMode === 2) {  // Only for 2-player mode (human control)
                if (!paddle2.isFrozen) {
                    if (keys.d) {
                        paddle2.dx = 5;
                    } else if (keys.a) {
                        paddle2.dx = -5;
                    } else {
                        // Apply friction to gradually stop paddle
                        paddle2.dx *= 0.8;
                    }
                    
                    // Apply movement
                    paddle2.x += paddle2.dx;
                } else {
                    // Frozen paddle can't move
                    paddle2.dx = 0;
                }
            } else {
                // If single player OR AI vs AI mode, implement AI for paddle2
                if (!paddle2.isFrozen) {
                    // Improved ball tracking logic - prioritize balls that are:
                    // 1. Owned by or last hit by this player
                    // 2. Moving toward this paddle
                    // 3. Closest to this paddle
                    
                    // Find balls moving toward this paddle (negative dy)
                    const approachingBalls = balls.filter(ball => ball.dy < 0);
                    
                    let ballToTrack;
                    
                    if (approachingBalls.length > 0) {
                        // First check if there's a ball owned by this player
                        ballToTrack = approachingBalls.find(ball => ball.lastHitBy === 2 || ball.owner === 2);
                        
                        // If no owned ball, pick the closest approaching ball
                        if (!ballToTrack) {
                            // Sort by closeness to this paddle (vertically)
                            approachingBalls.sort((a, b) => 
                                (a.y - paddle2.y) - (b.y - paddle2.y)
                            );
                            ballToTrack = approachingBalls[0];
                        }
                    } else {
                        // If no ball is approaching, track any ball
                        ballToTrack = balls.find(ball => ball.lastHitBy === 2 || ball.owner === 2) || balls[0];
                    }
                    
                    const targetX = ballToTrack.x - paddle2.width / 2;
                    const diff = targetX - paddle2.x;
                    
                    // Add some randomness to make AI less perfect
                    const randomness = (Math.random() - 0.5) * 15;
                    
                    // Smooth movement with error
                    if (Math.abs(diff) > 10) {
                        // Move faster when ball is further away
                        const speedFactor = Math.min(0.2, 0.1 + Math.abs(diff) / 1000);
                        paddle2.dx = diff * speedFactor + randomness * 0.05;
                        
                        // Limit AI paddle speed to match human player speed (5 pixels per frame)
                        const maxSpeed = 5;
                        if (paddle2.dx > maxSpeed) {
                            paddle2.dx = maxSpeed;
                        } else if (paddle2.dx < -maxSpeed) {
                            paddle2.dx = -maxSpeed;
                        }
                    } else {
                        paddle2.dx *= 0.8;
                    }
                    
                    // Apply movement
                    paddle2.x += paddle2.dx;
                } else {
                    // Frozen paddle can't move
                    paddle2.dx = 0;
                }
            }
            
            // Handle shooting freeze rays for Player 1
            if (paddle1.hasFreezeRay) {
                if (gameMode !== 3 && keys.Space) {
                    // Human player 1 shoots freeze ray
                    shootFreezeRay(1);
                    paddle1.hasFreezeRay = false;
                    player1PowerUpIndicator.style.display = "none";
                    soundFX.playFreezeRay(); // Instead of soundManager.play('freezeRay')
                    keys.Space = false; // Prevent holding the key
                } else if (gameMode === 3) {
                    // AI should shoot more strategically
                    // Check if the opponent paddle is in a good alignment for a hit
                    const paddleAlignmentThreshold = 20; // Acceptable offset for aiming
                    const paddleAlignmentThreshold = 20; // Acceptable offset for aiming
                    const isAligned = Math.abs(paddle2.x + paddle2.width / 2 - paddle1.x - paddle1.width / 2) < paddleAlignmentThreshold;
                    
                    // Higher chance to shoot when aligned, small random chance otherwise
                    if ((isAligned && Math.random() < 0.1) || Math.random() < 0.005) {
                        // Position paddle to better aim before shooting
                        const targetX = paddle1.x + paddle1.width / 2 - paddle2.width / 2;
                        // If we're close enough to the target position, shoot
                        if (Math.abs(paddle2.x - targetX) < 10 || isAligned) {
                            shootFreezeRay(1);
                            paddle1.hasFreezeRay = false;
                            player1PowerUpIndicator.style.display = "none";
                            soundFX.playFreezeRay(); // Instead of soundManager.play('freezeRay')
                            debug("AI 1 shoots freeze ray at AI 2");
                        }
                    }
                }
            }
            
            // Handle shooting freeze rays for Player 2
            if (paddle2.hasFreezeRay) {
                        }
                    }
                }
            }
            
            // Update frozen timers
            if (paddle1.isFrozen) {
                paddle1.frozenTimeRemaining -= 1/60; // Assuming 60 FPS
                if (paddle1.frozenTimeRemaining <= 0) {
                    paddle1.isFrozen = false;
                    debug("Player 1 unfrozen!");
                }
            }
            
            if (paddle2.isFrozen) {
                paddle2.frozenTimeRemaining -= 1/60; // Assuming 60 FPS
                if (paddle2.frozenTimeRemaining <= 0) {
                    paddle2.isFrozen = false;
                    debug("Player 2 unfrozen!");
                }
            }
            
            // Update wide paddle timers
            if (paddle1.isWide) {
                paddle1.widePaddleTimeRemaining -= 1/60; // Assuming 60 FPS
                if (paddle1.widePaddleTimeRemaining <= 0) {
                    paddle1.isWide = false;
                    // Reset paddle width to original and recenter
                    paddle1.x += (paddle1.width - paddle1.originalWidth) / 2;
                    paddle1.width = paddle1.originalWidth;
                    debug("Player 1 wide paddle power-up expired");
                }
            }
            
            if (paddle2.isWide) {
                paddle2.widePaddleTimeRemaining -= 1/60; // Assuming 60 FPS
                if (paddle2.widePaddleTimeRemaining <= 0) {
                    paddle2.isWide = false;
                    // Reset paddle width to original and recenter
                    paddle2.x += (paddle2.width - paddle2.originalWidth) / 2;
                    paddle2.width = paddle2.originalWidth;
                    debug("Player 2 wide paddle power-up expired");
                }
            }
            
            // Limit the paddles to not go off-screen
            if (paddle1.x < 0) paddle1.x = 0;
            if (paddle1.x + paddle1.width > canvas.width) paddle1.x = canvas.width - paddle1.width;
            
            if (paddle2.x < 0) paddle2.x = 0;
            if (paddle2.x + paddle2.width > canvas.width) paddle2.x = canvas.width - paddle2.width;

            // Handle shooting laser for Player 1
            if (paddle1.hasLaser) {
                if (gameMode !== 3 && keys.Space) {
                    // Human player 1 shoots laser
                    shootLaser(1);
                    paddle1.hasLaser = false;
                    player1LaserIndicator.style.display = "none";
                    soundFX.playLaserShoot();
                    keys.Space = false; // Prevent holding the key
                } else if (gameMode === 3) {
                if (gameMode === 2 && keys.s) {
                    // Human player 2 shoots freeze ray
                    shootFreezeRay(2);
                    paddle2.hasFreezeRay = false;
                    player2PowerUpIndicator.style.display = "none";
                    soundFX.playFreezeRay(); // Instead of soundManager.play('freezeRay')
                    keys.s = false; // Prevent holding the key
                } else if (gameMode !== 2) {
                    // AI should shoot more strategically
                        }
                    }
                }
            }
            
            // Handle shooting laser for Player 2
            if (paddle2.hasLaser) {
                    // Check if the opponent paddle is in a good alignment for a hit
                    const paddleAlignmentThreshold = 20; // Acceptable offset for aiming
                    const isAligned = Math.abs(paddle2.x + paddle2.width / 2 - paddle1.x - paddle1.width / 2) < paddleAlignmentThreshold;
                    
                    // Higher chance to shoot when aligned, small random chance otherwise
                    if ((isAligned && Math.random() < 0.1) || Math.random() < 0.005) {
                        // Position paddle to better aim before shooting
                        const targetX = paddle1.x + paddle1.width / 2 - paddle2.width / 2;
                        // If we're close enough to the target position, shoot
                        if (Math.abs(paddle2.x - targetX) < 10 || isAligned) {
                            shootFreezeRay(2);
                            paddle2.hasFreezeRay = false;
                            player2PowerUpIndicator.style.display = "none";
                            soundFX.playFreezeRay(); // Instead of soundManager.play('freezeRay')
                            debug(`${gameMode === 1 ? 'AI' : 'AI 2'} shoots freeze ray at ${gameMode === 1 ? 'Player 1' : 'AI 1'}`);
                if (gameMode === 2 && keys.s) {
                    // Human player 2 shoots laser
                    shootLaser(2);
                    paddle2.hasLaser = false;
                    player2LaserIndicator.style.display = "none";
                    soundFX.playLaserShoot();
                    keys.s = false; // Prevent holding the key
                } else if (gameMode !== 2) {
                    // AI should shoot strategically
                        }
                    }
                }
            }
            
            // Update frozen timers
            if (paddle1.isFrozen) {
                paddle1.frozenTimeRemaining -= 1/60; // Assuming 60 FPS
                if (paddle1.frozenTimeRemaining <= 0) {
                    paddle1.isFrozen = false;
                    debug("Player 1 unfrozen!");
                }
            }
            
            if (paddle2.isFrozen) {
                paddle2.frozenTimeRemaining -= 1/60; // Assuming 60 FPS
                if (paddle2.frozenTimeRemaining <= 0) {
                    paddle2.isFrozen = false;
                    debug("Player 2 unfrozen!");
                }
            }
            
            // Update wide paddle timers
            if (paddle1.isWide) {
                paddle1.widePaddleTimeRemaining -= 1/60; // Assuming 60 FPS
                if (paddle1.widePaddleTimeRemaining <= 0) {
                    paddle1.isWide = false;
                    // Reset paddle width to original and recenter
                    paddle1.x += (paddle1.width - paddle1.originalWidth) / 2;
                    paddle1.width = paddle1.originalWidth;
                    debug("Player 1 wide paddle power-up expired");
                }
            }
            
            if (paddle2.isWide) {
                paddle2.widePaddleTimeRemaining -= 1/60; // Assuming 60 FPS
                if (paddle2.widePaddleTimeRemaining <= 0) {
                    paddle2.isWide = false;
                    // Reset paddle width to original and recenter
                    paddle2.x += (paddle2.width - paddle2.originalWidth) / 2;
                    paddle2.width = paddle2.originalWidth;
                    debug("Player 2 wide paddle power-up expired");
                }
            }
            
            // Limit the paddles to not go off-screen
            if (paddle1.x < 0) paddle1.x = 0;
            if (paddle1.x + paddle1.width > canvas.width) paddle1.x = canvas.width - paddle1.width;
            
            if (paddle2.x < 0) paddle2.x = 0;
            if (paddle2.x + paddle2.width > canvas.width) paddle2.x = canvas.width - paddle2.width;

            // Handle shooting laser for Player 1
            if (paddle1.hasLaser) {
                if (gameMode !== 3 && keys.Space) {
                    // Human player 1 shoots laser
                    shootLaser(1);
                    paddle1.hasLaser = false;
                    player1LaserIndicator.style.display = "none";
                    soundFX.playLaserShoot(); // Instead of soundManager.play('laserShoot')
                    keys.Space = false; // Prevent holding the key
                } else if (gameMode === 3) {
                    // AI should shoot strategically
                    const paddleAlignmentThreshold = 20; // Acceptable offset for aiming
                    const isAligned = Math.abs(paddle2.x + paddle2.width / 2 - paddle1.x - paddle1.width / 2) < paddleAlignmentThreshold;
                    
                    if ((isAligned && Math.random() < 0.1) || Math.random() < 0.005) {
                        const targetX = paddle1.x + paddle1.width / 2 - paddle2.width / 2;
                        if (Math.abs(paddle2.x - targetX) < 10 || isAligned) {
                            shootLaser(2);
                            paddle2.hasLaser = false;
                            player2LaserIndicator.style.display = "none";
                            soundFX.playLaserShoot();
                            debug(`${gameMode === 1 ? 'AI' : 'AI 2'} shoots laser at ${gameMode === 1 ? 'Player 1' : 'AI 1'}`);
                    const paddleAlignmentThreshold = 20; // Acceptable offset for aiming
                    const isAligned = Math.abs(paddle1.x + paddle1.width / 2 - paddle2.x - paddle2.width / 2) < paddleAlignmentThreshold;
                    
                    if ((isAligned && Math.random() < 0.1) || Math.random() < 0.005) {
                        const targetX = paddle2.x + paddle2.width / 2 - paddle1.width / 2;
                        if (Math.abs(paddle1.x - targetX) < 10 || isAligned) {
                            shootLaser(1);
                            paddle1.hasLaser = false;
                            player1LaserIndicator.style.display = "none";
                            soundFX.playLaserShoot(); // Instead of soundManager.play('laserShoot')
                            debug("AI 1 shoots laser at AI 2");
                        }
                    }
                }
            }
            
            // Handle shooting laser for Player 2
            if (paddle2.hasLaser) {
                        }
                    }
                }
            }
            
            // Update ashes timers
            if (paddle1.isAshes) {
                paddle1.ashesTimeRemaining -= 1/60; // Assuming 60 FPS
                if (paddle1.ashesTimeRemaining <= 0) {
                    paddle1.isAshes = false;
                    debug("Player 1 returned from ashes!");
                }
            }
            
            if (paddle2.isAshes) {
                paddle2.ashesTimeRemaining -= 1/60; // Assuming 60 FPS
                if (paddle2.ashesTimeRemaining <= 0) {
                    paddle2.isAshes = false;
                    debug("Player 2 returned from ashes!");
                }
            }
        }

        // Function to shoot a freeze ray
        function shootFreezeRay(player) {
            const paddle = player === 1 ? paddle1 : paddle2;
            const ray = new FreezeRay(
                paddle.x + paddle.width / 2 - 2.5, // Center of paddle
                player === 1 ? paddle.y - 15 : paddle.y + paddle.height + 10, // Start from top/bottom of paddle
                player
            );
            freezeRays.push(ray);
            debug(`Player ${player} shot a freeze ray`);
        }

        // Function to shoot a laser beam
        function shootLaser(player) {
            const paddle = player === 1 ? paddle1 : paddle2;
            const beam = new LaserBeam(
                paddle.x + paddle.width / 2, // Center of paddle
                player === 1 ? paddle.y - 10 : paddle.y + paddle.height + 10, // Start from top/bottom of paddle
                player
            );
            laserBeams.push(beam);
            debug(`Player ${player} shot a laser beam!`);
        }

        // Function to return to start screen
        function returnToStartScreen() {
            debug("Returning to start screen");
            // Cancel game loop
            if (gameLoop) {
                cancelAnimationFrame(gameLoop);
                gameLoop = null;
            }
            
            // Reset game state
            gameMode = 0;
            
            // Display the start screen
            startScreen.style.display = 'block';
        }

        // Reset ball
        function resetBall(ballIndex) {
            const ball = balls[ballIndex];
            const speed = 3; // Consistent ball speed
            const angle = Math.random() * Math.PI / 2 + Math.PI / 4; // Random angle between 45 and 135 degrees
            
            if (ball.owner === 1) {
                ball.x = canvas.width / 2;
                ball.y = canvas.height - 50;
                // Calculate velocity components based on random angle (upward for player 1)
                ball.dx = speed * Math.cos(angle) * (Math.random() > 0.5 ? 1 : -1); // Random left or right
                ball.dy = -speed * Math.sin(angle); // Always upward for player 1
                ball.lastHitBy = 1; // Reset lastHitBy to the ball owner
            } else {
                ball.x = canvas.width / 2;
                ball.y = 50;
                // Calculate velocity components based on random angle (downward for player 2)
                ball.dx = speed * Math.cos(angle) * (Math.random() > 0.5 ? 1 : -1); // Random left or right
                ball.dy = speed * Math.sin(angle); // Always downward for player 2
                ball.lastHitBy = 2; // Reset lastHitBy to the ball owner
            }
            debug(`Ball ${ballIndex} reset: angle=${(angle * 180 / Math.PI).toFixed(2)}, dx=${ball.dx.toFixed(2)}, dy=${ball.dy.toFixed(2)}`);
        }

        // Reset bricks
        function resetBricks() {
            initBricks();
        }

        // Start game
        function startGame(mode) {
            gameMode = mode;
            debug(`Starting game in mode: ${mode === 1 ? 'Single Player' : 'Two Players'}`);
            startScreen.style.display = 'none';
            balls.forEach((_, index) => resetBall(index));
            resetBricks();
            paddle1.score = 0;
            paddle2.score = 0;
            paddle1.hasFreezeRay = false;
            paddle2.hasFreezeRay = false;
            paddle1.isFrozen = false;
            paddle2.isFrozen = false;
            paddle1.isWide = false;
            paddle2.isWide = false;
            paddle1.hasLaser = false;
            paddle2.hasLaser = false;
            paddle1.isAshes = false;
            paddle2.isAshes = false;
            player1PowerUpIndicator.style.display = "none";
            player2PowerUpIndicator.style.display = "none";
            
            if (gameLoop) {
                cancelAnimationFrame(gameLoop);
            }
            
            function animate() {
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Move paddles
                movePaddles();

                // Update and draw particles
                for (let i = particles.length - 1; i >= 0; i--) {
                    particles[i].update();
                    particles[i].draw(ctx);
                    if (particles[i].life <= 0) {
                        particles.splice(i, 1);
                    }
                }

                // Update and draw freeze rays
                for (let i = freezeRays.length - 1; i >= 0; i--) {
                    freezeRays[i].update();
                    freezeRays[i].draw();
                    if (!freezeRays[i].active) {
                        freezeRays.splice(i, 1);
                    }
                }

                // Update and draw laser beams
                for (let i = laserBeams.length - 1; i >= 0; i--) {
                    laserBeams[i].update();
                    laserBeams[i].draw();
                    if (!laserBeams[i].active) {
                        laserBeams.splice(i, 1);
                    }
                }

                // Handle both balls
                balls.forEach((ball, index) => {
                    // Move ball
                    ball.x += ball.dx;
                    ball.y += ball.dy;

                    // Ball collision with walls
                    if (ball.x + ball.radius > canvas.width) {
                        ball.x = canvas.width - ball.radius;
                        ball.dx = -Math.abs(ball.dx);
                        soundFX.playWallHit();
                        debug("Ball hit right wall");
                    } else if (ball.x - ball.radius < 0) {
                        ball.x = ball.radius;
                if (gameMode === 2 && keys.s) {
                    // Human player 2 shoots laser
                    shootLaser(2);
                    paddle2.hasLaser = false;
                    player2LaserIndicator.style.display = "none";
                    soundFX.playLaserShoot(); // Instead of soundManager.play('laserShoot')
                    keys.s = false; // Prevent holding the key
                } else if (gameMode !== 2) {
                    // AI should shoot strategically
                        ball.dx = Math.abs(ball.dx);
                        soundFX.playWallHit();
                        debug("Ball hit left wall");
                    }

                    // Ball collision with paddles
                    checkCollision(paddle1, ball) || checkCollision(paddle2, ball);
                    const paddleAlignmentThreshold = 20; // Acceptable offset for aiming
                    const isAligned = Math.abs(paddle2.x + paddle2.width / 2 - paddle1.x - paddle1.width / 2) < paddleAlignmentThreshold;
                    
                    if ((isAligned && Math.random() < 0.1) || Math.random() < 0.005) {
                        const targetX = paddle1.x + paddle1.width / 2 - paddle2.width / 2;
                        if (Math.abs(paddle2.x - targetX) < 10 || isAligned) {
                            shootLaser(2);
                            paddle2.hasLaser = false;
                            player2LaserIndicator.style.display = "none";
                            soundFX.playLaserShoot(); // Instead of soundManager.play('laserShoot')
                            debug(`${gameMode === 1 ? 'AI' : 'AI 2'} shoots laser at ${gameMode === 1 ? 'Player 1' : 'AI 1'}`);

                    // Ball collision with bricks
                    checkBrickCollision(ball);

                    // Ball out of bounds
                    if (ball.y + ball.radius > canvas.height) {
                        paddle2.score += 10;
                        soundFX.playBrickBreak();
                        debug(`Player 2 scored: ${paddle2.score}`);
                        resetBall(index);
                    }
                        }
                    }
                }
            }
            
            // Update ashes timers
            if (paddle1.isAshes) {
                paddle1.ashesTimeRemaining -= 1/60; // Assuming 60 FPS
                if (paddle1.ashesTimeRemaining <= 0) {
                    paddle1.isAshes = false;
                    debug("Player 1 returned from ashes!");
                }
            }
            
            if (paddle2.isAshes) {
                paddle2.ashesTimeRemaining -= 1/60; // Assuming 60 FPS
                if (paddle2.ashesTimeRemaining <= 0) {
                    paddle2.isAshes = false;
                    debug("Player 2 returned from ashes!");
                }
            }
        }

        // Function to shoot a freeze ray
        function shootFreezeRay(player) {
            const paddle = player === 1 ? paddle1 : paddle2;
            const ray = new FreezeRay(
                paddle.x + paddle.width / 2 - 2.5, // Center of paddle
                player === 1 ? paddle.y - 15 : paddle.y + paddle.height + 10, // Start from top/bottom of paddle
                player
            );
            freezeRays.push(ray);
            debug(`Player ${player} shot a freeze ray`);
        }

        // Function to shoot a laser beam
        function shootLaser(player) {
            const paddle = player === 1 ? paddle1 : paddle2;
            const beam = new LaserBeam(
                paddle.x + paddle.width / 2, // Center of paddle
                player === 1 ? paddle.y - 10 : paddle.y + paddle.height + 10, // Start from top/bottom of paddle
                player
            );
            laserBeams.push(beam);
            debug(`Player ${player} shot a laser beam!`);
        }

        // Function to return to start screen
        function returnToStartScreen() {
            debug("Returning to start screen");
            // Cancel game loop
            if (gameLoop) {
                cancelAnimationFrame(gameLoop);
                gameLoop = null;
            }
            
            // Reset game state
            gameMode = 0;
            
            // Display the start screen
            startScreen.style.display = 'block';
        }

        // Reset ball
        function resetBall(ballIndex) {
            const ball = balls[ballIndex];
            const speed = 3; // Consistent ball speed
            const angle = Math.random() * Math.PI / 2 + Math.PI / 4; // Random angle between 45 and 135 degrees
            
            if (ball.owner === 1) {
                ball.x = canvas.width / 2;
                ball.y = canvas.height - 50;
                // Calculate velocity components based on random angle (upward for player 1)
                ball.dx = speed * Math.cos(angle) * (Math.random() > 0.5 ? 1 : -1); // Random left or right
                ball.dy = -speed * Math.sin(angle); // Always upward for player 1
                ball.lastHitBy = 1; // Reset lastHitBy to the ball owner
            } else {
                ball.x = canvas.width / 2;
                ball.y = 50;
                // Calculate velocity components based on random angle (downward for player 2)
                ball.dx = speed * Math.cos(angle) * (Math.random() > 0.5 ? 1 : -1); // Random left or right
                ball.dy = speed * Math.sin(angle); // Always downward for player 2
                ball.lastHitBy = 2; // Reset lastHitBy to the ball owner
            }
            debug(`Ball ${ballIndex} reset: angle=${(angle * 180 / Math.PI).toFixed(2)}, dx=${ball.dx.toFixed(2)}, dy=${ball.dy.toFixed(2)}`);
        }

        // Reset bricks
        function resetBricks() {
            initBricks();
        }

        // Start game
        function startGame(mode) {
            gameMode = mode;
            debug(`Starting game in mode: ${mode === 1 ? 'Single Player' : 'Two Players'}`);
            startScreen.style.display = 'none';
            balls.forEach((_, index) => resetBall(index));
            resetBricks();
            paddle1.score = 0;
            paddle2.score = 0;
            paddle1.hasFreezeRay = false;
            paddle2.hasFreezeRay = false;
            paddle1.isFrozen = false;
            paddle2.isFrozen = false;
            paddle1.isWide = false;
            paddle2.isWide = false;
            paddle1.hasLaser = false;
            paddle2.hasLaser = false;
            paddle1.isAshes = false;
            paddle2.isAshes = false;
            player1PowerUpIndicator.style.display = "none";
            player2PowerUpIndicator.style.display = "none";
            
            if (gameLoop) {
                cancelAnimationFrame(gameLoop);
            }
            
            function animate() {
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Move paddles
                movePaddles();

                // Update and draw particles
                for (let i = particles.length - 1; i >= 0; i--) {
                    particles[i].update();
                    particles[i].draw(ctx);
                    if (particles[i].life <= 0) {
                        particles.splice(i, 1);
                    }
                }

                // Update and draw freeze rays
                for (let i = freezeRays.length - 1; i >= 0; i--) {
                    freezeRays[i].update();
                    freezeRays[i].draw();
                    if (!freezeRays[i].active) {
                        freezeRays.splice(i, 1);
                    }
                }

                // Update and draw laser beams
                for (let i = laserBeams.length - 1; i >= 0; i--) {
                    laserBeams[i].update();
                    laserBeams[i].draw();
                    if (!laserBeams[i].active) {
                        laserBeams.splice(i, 1);
                    }
                }

                // Handle both balls
                balls.forEach((ball, index) => {
                    // Move ball
                    ball.x += ball.dx;
                    ball.y += ball.dy;

                    // Ball collision with walls
                    if (ball.x + ball.radius > canvas.width) {
                        ball.x = canvas.width - ball.radius;
                        ball.dx = -Math.abs(ball.dx);
                        soundFX.playWallHit(); // Instead of soundManager.play('wallHit')
                        debug("Ball hit right wall");
                    } else if (ball.x - ball.radius < 0) {
                        ball.x = ball.radius;
                    
                    if (ball.y - ball.radius < 0) {
                        paddle1.score += 10;
                        soundFX.playBrickBreak();
                        debug(`Player 1 scored: ${paddle1.score}`);
                        resetBall(index);
                    }
                });

                // Draw game elements
                        ball.dx = Math.abs(ball.dx);
                        soundFX.playWallHit(); // Instead of soundManager.play('wallHit')
                        debug("Ball hit left wall");
                    }

                    // Ball collision with paddles
                drawPaddle(paddle1);
                drawPaddle(paddle2);
                drawBall();
                drawBricks();
                drawScore();
                
                // Continue animation
                gameLoop = requestAnimationFrame(animate);
            }
            
            // Start animation
            gameLoop = requestAnimationFrame(animate);
            
            soundFX.playGameStart();
        }
        
        // Initialize bricks
        initBricks();

        // Ball collision with paddles
        function checkCollision(paddle, ball) {
                    checkCollision(paddle1, ball) || checkCollision(paddle2, ball);

                    // Ball collision with bricks
                    checkBrickCollision(ball);

                    // Ball out of bounds
                    if (ball.y + ball.radius > canvas.height) {
                        paddle2.score += 10;
                        soundFX.playScore(); // Instead of soundManager.play('score')
                        debug(`Player 2 scored: ${paddle2.score}`);
                        resetBall(index);
            // Skip collision detection if paddle is turned to ashes
            if (paddle.isAshes) {
                return false;
            }
            
            // Calculate the horizontal center of the paddle
            const paddleCenter = paddle.x + (paddle.width / 2);
            
            // Check for collision with paddle
            if (paddle === paddle1) {
                // Bottom paddle (Player 1)
                if (ball.y + ball.radius > paddle.y && 
                    ball.y - ball.radius < paddle.y + paddle.height && 
                    ball.x + ball.radius > paddle.x && 
                    ball.x - ball.radius < paddle.x + paddle.width) {
                    
                    // Only bounce if the ball is moving downward
                    if (ball.dy > 0) {
                        // Calculate impact point relative to center (-1 to 1)
                        const impactPoint = (ball.x - paddleCenter) / (paddle.width / 2);
                        
                        // Calculate the new angle based on where the ball hit the paddle
                        // -1.0 = 60 to the left, 0 = straight up, 1.0 = 60 to the right
                        const maxAngle = Math.PI / 3; // 60 degrees in radians
                        const newAngle = impactPoint * maxAngle;
                        
                        // Calculate new ball direction - speed depends on distance from center
                        const speed = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
                        const newSpeed = speed * (1.0 + Math.abs(impactPoint) * 0.2); // Ball speeds up on edge hits
                        
                        ball.dx = newSpeed * Math.sin(newAngle);
                        ball.dy = -newSpeed * Math.cos(newAngle);
                        
                        // Move ball above paddle to prevent sticking
                        ball.y = paddle.y - ball.radius;
                        
                        // Update last hit property
                        ball.lastHitBy = 1;
                        
                        soundFX.playPaddleHit();
                        debug(`Player 1 hit ball: impact=${impactPoint.toFixed(2)}, angle=${(newAngle * 180 / Math.PI).toFixed(2)}`);
                    }
                    
                    if (ball.y - ball.radius < 0) {
                        paddle1.score += 10;
                        soundFX.playScore(); // Instead of soundManager.play('score')
                        debug(`Player 1 scored: ${paddle1.score}`);
                        resetBall(index);
                    }
                });

                // Draw game elements
                drawPaddle(paddle1);
                        
                        return true;
                    }
                }
            } else {
                // Top paddle (Player 2)
                if (ball.y + ball.radius > paddle.y && 
                    ball.y - ball.radius < paddle.y + paddle.height && 
                    ball.x + ball.radius > paddle.x && 
                    ball.x - ball.radius < paddle.x + paddle.width) {
                    
                    // Only bounce if the ball is moving upward
                    if (ball.dy < 0) {
                        // Calculate impact point relative to center (-1 to 1)
                        const impactPoint = (ball.x - paddleCenter) / (paddle.width / 2);
                        
                        // Calculate the new angle based on where the ball hit the paddle
                        // -1.0 = 60 to the left, 0 = straight down, 1.0 = 60 to the right
                        const maxAngle = Math.PI / 3; // 60 degrees in radians
                        const newAngle = impactPoint * maxAngle;
                        
                        // Calculate new ball direction - speed depends on distance from center
                        const speed = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
                        const newSpeed = speed * (1.0 + Math.abs(impactPoint) * 0.2); // Ball speeds up on edge hits
                        
                        ball.dx = newSpeed * Math.sin(newAngle);
                        ball.dy = newSpeed * Math.cos(newAngle);
                        
                        // Move ball below paddle to prevent sticking
                        ball.y = paddle.y + paddle.height + ball.radius;
                        
                        // Update last hit property
                        ball.lastHitBy = 2;
                        
                        soundFX.playPaddleHit();
                        debug(`Player 2 hit ball: impact=${impactPoint.toFixed(2)}, angle=${(newAngle * 180 / Math.PI).toFixed(2)}`);
                drawPaddle(paddle2);
                drawBall();
                drawBricks();
                drawScore();
                
                // Continue animation
                gameLoop = requestAnimationFrame(animate);
            }
            
            // Start animation
            gameLoop = requestAnimationFrame(animate);
            
            soundFX.playGameStart(); // Instead of soundManager.play('gameStart')
        }
        
        // Initialize bricks
        initBricks();

        // Ball collision with paddles
        function checkCollision(paddle, ball) {
                        
                        return true;
                    }
                }
            }
            
            return false;
        }

        // Enhanced sound effects using Web Audio API
        const soundFX = {
            audioContext: null,
            
            init() {
                if (!this.audioContext) {
                    try {
                        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    } catch (e) {
                        console.error("Web Audio API not supported:", e);
                    }
                }
                return this.audioContext !== null;
            },
            
            // Ball hits paddle
            // Skip collision detection if paddle is turned to ashes
            if (paddle.isAshes) {
                return false;
            }
            
            // Calculate the horizontal center of the paddle
            const paddleCenter = paddle.x + (paddle.width / 2);
            
            // Check for collision with paddle
            if (paddle === paddle1) {
                // Bottom paddle (Player 1)
                if (ball.y + ball.radius > paddle.y && 
                    ball.y - ball.radius < paddle.y + paddle.height && 
                    ball.x + ball.radius > paddle.x && 
                    ball.x - ball.radius < paddle.x + paddle.width) {
                    
                    // Only bounce if the ball is moving downward
                    if (ball.dy > 0) {
                        // Calculate impact point relative to center (-1 to 1)
                        const impactPoint = (ball.x - paddleCenter) / (paddle.width / 2);
                        
                        // Calculate the new angle based on where the ball hit the paddle
                        // -1.0 = 60 to the left, 0 = straight up, 1.0 = 60 to the right
                        const maxAngle = Math.PI / 3; // 60 degrees in radians
                        const newAngle = impactPoint * maxAngle;
                        
                        // Calculate new ball direction - speed depends on distance from center
                        const speed = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
                        const newSpeed = speed * (1.0 + Math.abs(impactPoint) * 0.2); // Ball speeds up on edge hits
                        
                        ball.dx = newSpeed * Math.sin(newAngle);
                        ball.dy = -newSpeed * Math.cos(newAngle);
                        
                        // Move ball above paddle to prevent sticking
                        ball.y = paddle.y - ball.radius;
                        
                        // Update last hit property
                        ball.lastHitBy = 1;
                        
                        soundFX.playPaddleHit(Math.abs(impactPoint)); // Instead of soundManager.play('paddleHit')
                        debug(`Player 1 hit ball: impact=${impactPoint.toFixed(2)}, angle=${(newAngle * 180 / Math.PI).toFixed(2)}`);
            playPaddleHit(impact = 0.5) {
                        
                        return true;
                    }
                }
            } else {
                // Top paddle (Player 2)
                if (ball.y + ball.radius > paddle.y && 
                    ball.y - ball.radius < paddle.y + paddle.height && 
                    ball.x + ball.radius > paddle.x && 
                    ball.x - ball.radius < paddle.x + paddle.width) {
                    
                    // Only bounce if the ball is moving upward
                    if (ball.dy < 0) {
                        // Calculate impact point relative to center (-1 to 1)
                        const impactPoint = (ball.x - paddleCenter) / (paddle.width / 2);
                        
                        // Calculate the new angle based on where the ball hit the paddle
                        // -1.0 = 60 to the left, 0 = straight down, 1.0 = 60 to the right
                        const maxAngle = Math.PI / 3; // 60 degrees in radians
                        const newAngle = impactPoint * maxAngle;
                        
                        // Calculate new ball direction - speed depends on distance from center
                        const speed = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
                        const newSpeed = speed * (1.0 + Math.abs(impactPoint) * 0.2); // Ball speeds up on edge hits
                        
                        ball.dx = newSpeed * Math.sin(newAngle);
                        ball.dy = newSpeed * Math.cos(newAngle);
                        
                        // Move ball below paddle to prevent sticking
                        ball.y = paddle.y + paddle.height + ball.radius;
                        
                        // Update last hit property
                        ball.lastHitBy = 2;
                        
                        soundFX.playPaddleHit(Math.abs(impactPoint)); // Instead of soundManager.play('paddleHit')
                if (!this.init()) return;
                
                const ctx = this.audioContext;
                        debug(`Player 2 hit ball: impact=${impactPoint.toFixed(2)}, angle=${(newAngle * 180 / Math.PI).toFixed(2)}`);
                        
                        return true;
                    }
                }
            }
            
            return false;
        }

        // Audio setup for sound effects
        let audioContext;

        // Initialize audio context (must be after user interaction)
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        // Function to play beep sound
        function playBeep(frequency, duration) {
            if (!audioContext) {
                try {
                    initAudio();
                } catch (e) {
                    console.error("Could not initialize audio:", e);
                    return;
                }
            }
            
            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.type = 'sine';
                oscillator.frequency.value = frequency;
                gainNode.gain.value = 0.1;
                
                oscillator.start();
                
                // Stop the sound after the specified duration
                setTimeout(() => {
                    oscillator.stop();
                }, duration * 1000);
            } catch (e) {
                console.error("Error playing sound:", e);
            }
        }

        // Enhanced sound effects using Web Audio API
        const soundFX = {
            audioContext: null,
            
            init() {
                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
            },
            
            playBrickBreak(brick) {
                this.init();
                
                // Create noise burst with filter for brick break sound
                const bufferSize = 4096;
                const whiteNoise = this.audioContext.createScriptProcessor(bufferSize, 1, 1);
                const filter = this.audioContext.createBiquadFilter();
                const gainNode = this.audioContext.createGain();
                
                // Connect nodes
                whiteNoise.connect(filter);
                filter.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                // Configure noise generator
                whiteNoise.onaudioprocess = (e) => {
                    const output = e.outputBuffer.getChannelData(0);
                    for (let i = 0; i < bufferSize; i++) {
                        output[i] = Math.random() * 2 - 1;
                    }
                };
                
                // Configure filter based on brick type
                if (brick.status === BRICK_POWER_UP) {
                    filter.type = "bandpass";
                    filter.frequency.value = 800;
                    filter.Q.value = 5;
                } else if (brick.status === BRICK_WIDE_PADDLE) {
                    filter.type = "highpass";
                    filter.frequency.value = 1000;
                } else if (brick.status === BRICK_LASER_POWER_UP) {
                    filter.type = "lowpass";
                    filter.frequency.value = 400;
                } else {
                    filter.type = "bandpass";
                    filter.frequency.value = 600;
                    filter.Q.value = 1;
                }
                
                // Create envelope
                gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.3, this.audioContext.currentTime + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.00001, this.audioContext.currentTime + 0.3);
                
                // Stop the processor after sound is complete
                setTimeout(() => {
                    whiteNoise.disconnect();
                    filter.disconnect();
                    gainNode.disconnect();
                }, 500);
            },
            
            playLaser() {
                this.init();
                
                // Create oscillator for laser sound
                const osc = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                // Connect nodes
                osc.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                // Configure laser sound
                osc.type = "sawtooth";
                osc.frequency.setValueAtTime(800, this.audioContext.currentTime);
                osc.frequency.linearRampToValueAtTime(400, this.audioContext.currentTime + 0.2);
                
                // Volume envelope
                gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.3, this.audioContext.currentTime + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.00001, this.audioContext.currentTime + 0.3);
                
                // Start and stop
                osc.start();
                osc.stop(this.audioContext.currentTime + 0.3);
            },
            
            // Add more specialized sound effect methods here
        };

        // Sound assets - add after game constants
        const SOUNDS = {
            paddleHit: 'sounds/paddle-hit.mp3',
            wallHit: 'sounds/wall-hit.mp3',
            brickBreak: 'sounds/brick-break.mp3',
            brickPowerUp: 'sounds/power-up.mp3',
            laserShoot: 'sounds/laser-shoot.mp3',
            laserHit: 'sounds/laser-hit.mp3',
            freezeRay: 'sounds/freeze-ray.mp3',
            score: 'sounds/score.mp3',
            gameStart: 'sounds/game-start.mp3',
            levelComplete: 'sounds/level-complete.mp3'
        };

        // Sound manager - add after audio setup
        const soundManager = {
            sounds: {},
            muted: false,
            
            init() {
                // Pre-load all sounds
                for (const [key, path] of Object.entries(SOUNDS)) {
                    this.sounds[key] = new Audio(path);
                    this.sounds[key].volume = 0.3; // Default volume
                }
                
                // Add background music with looping
                this.sounds.bgMusic = new Audio('sounds/background-music.mp3');
                this.sounds.bgMusic.loop = true;
                this.sounds.bgMusic.volume = 0.1; // Lower volume for background music
            },
            
            play(soundName, volume = null) {
                if (this.muted || !this.sounds[soundName]) return;
                
                // Create a clone to allow overlapping sounds
                const sound = this.sounds[soundName].cloneNode();
                if (volume !== null) sound.volume = volume;
                
                sound.play().catch(e => console.error("Error playing sound:", e));
                
                // Return sound for advanced control
                return sound;
            },
            
            startMusic() {
                if (this.muted) return;
                this.sounds.bgMusic.play().catch(e => console.error("Error playing music:", e));
            },
            
            stopMusic() {
                this.sounds.bgMusic.pause();
                this.sounds.bgMusic.currentTime = 0;
            },
            
            toggleMute() {
                this.muted = !this.muted;
                if (this.muted) {
                    this.sounds.bgMusic.pause();
                } else {
                    this.sounds.bgMusic.play().catch(e => {});
                }
                return this.muted;
            }
        };
    </script>
</body>
</html>
